diff -rupN ../../Archives/vboot_20100106/vboot/244x_lib.c vboot//244x_lib.c
--- vboot/244x_lib.c	2011-12-22 17:11:57.703281007 +0000
+++ vboot//244x_lib.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,60 +0,0 @@
-
-#include "def.h"
-#include "s3c2440.h"
-#include "244x_lib.h"
-
-#if 1
-void *memset(void *dst, int src, unsigned int len)
-{
-	char *p = dst;
-	while (len--)
-		*p++ = src;
-	return dst;
-}
-void *memcpy(void *dst, const void *src, unsigned int len)
-{
-	const char *s = src;
-	      char *d = dst;
-	while (len --) {
-		*d++ = *s++;
-	}
-	return dst;
-}
-#endif
-
-void Port_Init(void)
-{
-	GPACON = 0x7fffff;
-	GPBCON = 0x044555;
-	GPBUP = 0x7ff;		// The pull up function is disabled GPB[10:0]
-	GPCCON = 0xaaaaaaaa;
-	GPCUP = 0xffff;	// The pull up function is disabled GPC[15:0] 
-	GPDCON = 0x00151544;
-	GPDDAT = 0x0430;
-	GPDUP = 0x877A;
-	GPECON = 0xaa2aaaaa;
-	GPEUP = 0xf7ff;	// GPE11 is NC
-	GPFCON = 0x55aa;
-	GPFUP = 0xff;		// The pull up function is disabled GPF[7:0]
-	GPGCON = 1<<8;
-	GPGDAT = 0;
-	GPHCON = 0x16faaa;
-	GPHUP = 0x7ff;		// The pull up function is disabled GPH[10:0]
-	EXTINT0 = 0x22222222;	// EINT[7:0]
-	EXTINT1 = 0x22222222;	// EINT[15:8]
-	EXTINT2 = 0x22222222;	// EINT[23:16]
-}
-
-//=====================================================================
-static inline void Uart_SendByte(int data)
-{
-	while (!(UTRSTAT0 & 0x2)) ;	//Wait until THR is empty.
-	UTXH0 = data;
-}
-
-//====================================================================
-void Uart_SendString(char *pt)
-{
-	while (*pt)
-		Uart_SendByte(*pt++);
-}
diff -rupN ../../Archives/vboot_20100106/vboot/244x_lib.h vboot//244x_lib.h
--- vboot/244x_lib.h	2011-12-22 17:11:57.704280995 +0000
+++ vboot//244x_lib.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,25 +0,0 @@
-//===================================================================
-// File Name : 2442lib.h
-// Function  : S3C2442 
-// Date      : February 26, 2002
-// Version   : 0.0
-// History
-//  0.0 :Feb.20.2002:SOP     : Programming start
-//  0.01:Mar.29.2002:purnnamu: For POWEROFF_wake_up, the START... label is added
-//===================================================================
-
-#ifndef __2442lib_h__
-#define __2442lib_h__
-#define NO_USE_STANDARD_C_LIB
-
-void *memset(void *dst, int src, unsigned int len);
-void *memcpy(void *dst, const void *src, unsigned int len);
-
-#define min(x1,x2) (((x1)<(x2))? (x1):(x2))
-#define max(x1,x2) (((x1)>(x2))? (x1):(x2))
-
-// 2442lib.c
-void Port_Init(void);
-void Uart_SendString(char *pt);
-
-#endif				//__2442lib_h__
diff -rupN ../../Archives/vboot_20100106/vboot/Makefile vboot//Makefile
--- vboot/Makefile	2011-12-22 17:11:57.712280895 +0000
+++ vboot//Makefile	2011-12-22 16:35:42.063480249 +0000
@@ -1,10 +1,10 @@
 
 
 all:
-	arm-linux-gcc -mabi=aapcs-linux -mno-thumb-interwork -Os -Wall -c head.S 244x_lib.c nand.c main.c
-	arm-linux-ld -T mem.lds -Bstatic head.o 244x_lib.o nand.o main.o 
-	arm-linux-objcopy -O binary -S a.out vboot.bin -R .comment -R .stab -R .stabstr
-	rm *.o a.out
+	arm-jbtheou-linux-uclibcgnueabi-gcc -mabi=aapcs-linux   -I . -O2 -Os -Wall -c head.S main.c
+	arm-jbtheou-linux-uclibcgnueabi-ld -T mem.lds -Bstatic head.o main.o
+	arm-jbtheou-linux-uclibcgnueabi-objcopy -O binary -S a.out vboot.bin -R .comment -R .stab -R .stabstr
+	#rm *.o a.out
 
 clean:
 	rm vboot.bin
diff -rupN ../../Archives/vboot_20100106/vboot/README vboot//README
--- vboot/README	1970-01-01 00:00:00.000000000 +0000
+++ vboot//README	2011-12-22 16:35:42.066480211 +0000
@@ -0,0 +1,22 @@
+@ Quelques tests qui fonctionne ! 
+@
+@ S3C244X: core 429.600 MHz, memory 107.400 MHz, peripheral 53.700 MHz
+@ Calibrating delay loop... 213.81 BogoMIPS (lpj=534528)
+@ #define UART_PCLK           53700000
+@ #define vMPLLCON_NOW_USER ((171 << 12) + (0x3 << 4) + 0x1)
+@ #define vCLKDIVN_NOW        CLKDVIN_400_148
+@ #define vREFRESH            vREFRESH_400_148
+@ #define TACLS			0	// 1-clk(0ns)
+@ #define TWRPH0		1	// 3-clk(25ns)
+@ #define TWRPH1		1	// 1-clk(10ns)  //TACLS+TWRPH0+TWRPH1>=50ns
+@
+@ La modification du timing de la nand fait perde l'avantage de l'augmentation
+@ de la fréquence
+@
+@ Augmentation max sans modification du timing de 
+@
+@ #define UART_PCLK			  53100000
+@ #define vMPLLCON_NOW_USER   ((169 << 12) + (0x3 << 4) + 0x1)
+@ #define vCLKDIVN_NOW        CLKDVIN_400_148
+@ #define vREFRESH            vREFRESH_412_148
+@
diff -rupN ../../Archives/vboot_20100106/vboot/bitfield.h vboot//bitfield.h
--- vboot/bitfield.h	2011-12-22 17:11:57.705280983 +0000
+++ vboot//bitfield.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,106 +0,0 @@
-/*
- *	FILE    	bitfield.h
- *
- *	Version 	1.1
- *	Author  	Copyright (c) Marc A. Viredaz, 1998
- *	        	DEC Western Research Laboratory, Palo Alto, CA
- *	Date    	April 1998 (April 1997)
- *	System  	Advanced RISC Machine (ARM)
- *	Language	C or ARM Assembly
- *	Purpose 	Definition of macros to operate on bit fields.
- */
-
-#ifndef __BITFIELD_H
-#define __BITFIELD_H
-
-#ifndef __ASSEMBLY__
-#define UData(Data)	((unsigned long) (Data))
-#else
-#define UData(Data)	(Data)
-#endif
-
-/*
- * MACRO: Fld
- *
- * Purpose
- *    The macro "Fld" encodes a bit field, given its size and its shift value
- *    with respect to bit 0.
- *
- * Note
- *    A more intuitive way to encode bit fields would have been to use their
- *    mask. However, extracting size and shift value information from a bit
- *    field's mask is cumbersome and might break the assembler (255-character
- *    line-size limit).
- *
- * Input
- *    Size      	Size of the bit field, in number of bits.
- *    Shft      	Shift value of the bit field with respect to bit 0.
- *
- * Output
- *    Fld       	Encoded bit field.
- */
-
-#define Fld(Size, Shft)	(((Size) << 16) + (Shft))
-
-/*
- * MACROS: FSize, FShft, FMsk, FAlnMsk, F1stBit
- *
- * Purpose
- *    The macros "FSize", "FShft", "FMsk", "FAlnMsk", and "F1stBit" return
- *    the size, shift value, mask, aligned mask, and first bit of a
- *    bit field.
- *
- * Input
- *    Field     	Encoded bit field (using the macro "Fld").
- *
- * Output
- *    FSize     	Size of the bit field, in number of bits.
- *    FShft     	Shift value of the bit field with respect to bit 0.
- *    FMsk      	Mask for the bit field.
- *    FAlnMsk   	Mask for the bit field, aligned on bit 0.
- *    F1stBit   	First bit of the bit field.
- */
-
-#define FSize(Field)	((Field) >> 16)
-#define FShft(Field)	((Field) & 0x0000FFFF)
-#define FMsk(Field)	(((UData (1) << FSize (Field)) - 1) << FShft (Field))
-#define FAlnMsk(Field)	((UData (1) << FSize (Field)) - 1)
-#define F1stBit(Field)	(UData (1) << FShft (Field))
-
-/*
- * MACRO: FInsrt
- *
- * Purpose
- *    The macro "FInsrt" inserts a value into a bit field by shifting the
- *    former appropriately.
- *
- * Input
- *    Value     	Bit-field value.
- *    Field     	Encoded bit field (using the macro "Fld").
- *
- * Output
- *    FInsrt    	Bit-field value positioned appropriately.
- */
-
-#define FInsrt(Value, Field) \
-                	(UData (Value) << FShft (Field))
-
-/*
- * MACRO: FExtr
- *
- * Purpose
- *    The macro "FExtr" extracts the value of a bit field by masking and
- *    shifting it appropriately.
- *
- * Input
- *    Data      	Data containing the bit-field to be extracted.
- *    Field     	Encoded bit field (using the macro "Fld").
- *
- * Output
- *    FExtr     	Bit-field value.
- */
-
-#define FExtr(Data, Field) \
-                	((UData (Data) >> FShft (Field)) & FAlnMsk (Field))
-
-#endif				/* __BITFIELD_H */
diff -rupN ../../Archives/vboot_20100106/vboot/def.h vboot//def.h
--- vboot/def.h		2011-12-22 17:11:57.706280971 +0000
+++ vboot//def.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,11 +0,0 @@
-#ifndef __DEF_H__
-#define __DEF_H__
-
-#define U32 unsigned int
-#define U16 unsigned short
-#define S32 int
-#define S16 short int
-#define U8  unsigned char
-#define	S8  char
-
-#endif /*__DEF_H__*/
diff -rupN ../../Archives/vboot_20100106/vboot/hardware.h vboot//hardware.h
--- vboot/hardware.h	2011-12-22 17:11:57.707280959 +0000
+++ vboot//hardware.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,26 +0,0 @@
-#ifndef _HARDWARE_H_
-#define _HARDWARE_H_
-
-#define CTL_REG_READ(addr)		(*(volatile unsigned long *)(addr))
-#define CTL_REG_WRITE(addr, val)	(*(volatile unsigned long *)(addr) = (val))
-
-#define CTL_REG_READ_BYTE(addr)		(*(volatile unsigned char *)(addr))
-#define CTL_REG_WRITE_BYTE(addr, val)	(*(volatile unsigned char *)(addr) = (val))
-
-#ifndef __ASSEMBLY__
-
-#define __REG(x)	(*(volatile unsigned long *)(x))
-#define __REGl(x)	(*(volatile unsigned long *)(x))
-#define __REGw(x)	(*(volatile unsigned short *)(x))
-#define __REGb(x)	(*(volatile unsigned char *)(x))
-
-#else
-
-#define __REG(x)	(x)
-#define __REGl(x)	(x)
-#define __REGw(x)	(x)
-#define __REGb(x)	(x)
-
-#endif
-
-#endif				/* _HARDWARE_H_ */
diff -rupN ../../Archives/vboot_20100106/vboot/head.S vboot//head.S
--- vboot/head.S	2011-12-22 17:11:57.709280933 +0000
+++ vboot//head.S	2011-12-22 17:13:01.804479633 +0000
@@ -1,7 +1,8 @@
 /*
  * s3c2440 head.S:
  *   Initialise hardware
- *
+ * 
+ * Copyright (C) 2011 Théou Jean-Baptiste 
  * Copyright (C) 2001 MIZI Research, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -19,79 +20,36 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  *
- * Author: Janghoon Lyu <nandy@mizi.com>
- * Date  : $Date: 2007-07-03 13:55:10 $
+ * Author: Théou Jean-Baptiste <jbtheou@gmail.com>
+ * Date  : $Date: 2011-11-23 11:00:10 $
  *
- * $Revision: 1.2 $
+ * $Revision: 2.0$
  *
  *
  * History:
- *
+ * 2007-07-03: Janghoon Lyu <nandy@mizi.com>
+ * 	 - Revision 1.2		
  * 2002-05-14: Janghoon Lyu <nandy@mizi.com>
  *   - Initial code
  *
  */
-#define __ASSEMBLY__
-
-#include "s3c2440.h"
-#include "smdk2440.h"
-#include "parameters.h"
+#include "head.h"
 
 @ Start of executable code 
 
-/* Fin = 12MHz */
-#define S3C2440_UPLL_48MHZ_Fin12MHz     ((0x38<<12)|(0x02<<4)|(0x02))
-
 @
 @ Exception vector table (physical address = 0x00000000)
 @
-
 	.section .text.FirstSector
 	.globl first_sector
 
 first_sector:
 @ 0x00: Reset
 	b	Reset
-
-@ 0x04: Undefined instruction exception
-UndefEntryPoint:
-	b	UndefEntryPoint
-
-@ 0x08: Software interrupt exception
-SWIEntryPoint:
-	b	SWIEntryPoint
-
-@ 0x0c: Prefetch Abort (Instruction Fetch Memory Abort)
-PrefetchAbortEnteryPoint:
-	b	PrefetchAbortEnteryPoint
-
-@ 0x10: Data Access Memory Abort
-DataAbortEntryPoint:
-	b	DataAbortEntryPoint
-
-@ 0x14: Not used
-NotUsedEntryPoint:
-	b	NotUsedEntryPoint
-
-@ 0x18: IRQ(Interrupt Request) exception
-IRQEntryPoint:
-	b	IRQHandle
-
-@ 0x1c: FIQ(Fast Interrupt Request) exception
-FIQEntryPoint:
-	b	FIQEntryPoint
-
-@0x20: Fixed address global value. will be replaced by downloader.
-
-	.long ZBOOT_MAGIC
-	.byte OS_TYPE, HAS_NAND_BIOS, (LOGO_POS & 0xFF), ((LOGO_POS >>8) &0xFF)
-	.long OS_START
-	.long OS_LENGTH
-	.long OS_RAM_START
-	.string LINUX_CMD_LINE
-
+	
 	.section .text
 Reset:
+	
 	@ disable watch dog timer
 	mov	r1, #0x53000000
 	mov	r2, #0x0
@@ -108,58 +66,115 @@ Reset:
 	mov	r1, #CLK_CTL_BASE
 	mvn	r2, #0xff000000
 	str	r2, [r1, #oLOCKTIME]
-	
 	mov	r1, #CLK_CTL_BASE
-	ldr	r2, clkdivn_value
-	str	r2, [r1, #oCLKDIVN]
-
+	ldr	r2, clkdivn_value			
+	str	r2, [r1, #oCLKDIVN]	
 	mrc	p15, 0, r1, c1, c0, 0		@ read ctrl register 
 	orr	r1, r1, #0xc0000000		@ Asynchronous  
 	mcr	p15, 0, r1, c1, c0, 0		@ write ctrl register
-
 	mov	r1, #CLK_CTL_BASE
-
-	ldr r2, =S3C2440_UPLL_48MHZ_Fin12MHz
-	str r2, [r1, #oUPLLCON]
-
-	nop
-	nop
-	nop
-	nop
-	nop
-	nop
-	nop
-	nop
-	nop
-	
-	ldr	sp, DW_STACK_START	@ setup stack pointer
-
+	ldr 	r2, =S3C2440_UPLL_48MHZ_Fin12MHz
+	str 	r2, [r1, #oUPLLCON]
+	ldr	sp, DW_STACK_START		@ setup stack pointer
 	ldr 	r2, mpll_value_USER 		@ clock user set 12MHz
 	str	r2, [r1, #oMPLLCON]
 	bl	memsetup
 
-	@ set GPIO for UART
+	@ Init MMU
+
+	@ I Cache
+	mrc p15,0,r0,c1,c0,0
+	orr r0,r0,#(1<<12)
+   	mcr p15,0,r0,c1,c0,0
+
+    	@ D cache
+	mrc p15,0,r0,c1,c0,0
+	orr r0,r0,#(1<<2)
+	mcr p15,0,r0,c1,c0,0
+
+	@ Init GPIO for ADC (pin for touchpad)
 	mov	r1, #GPIO_CTL_BASE
-	add	r1, r1, #oGPIO_H
-	ldr	r2, gpio_con_uart	
+	add	r1, r1, #oGPIO_C
+	ldr	r2, gpio_con_adc	
 	str	r2, [r1, #oGPIO_CON]
-	ldr	r2, gpio_up_uart
+	ldr	r2, gpio_up_adc
 	str	r2, [r1, #oGPIO_UP]	
-	bl	InitUART
-
+	
+	@ Init GPIO for external interrupt (Low latency without !!! )
+	mov	r1, #GPIO_CTL_BASE
+	ldr	r2, gpio_con_extint0	
+	str	r2, [r1, #oEXTINT0]
+	ldr	r2, gpio_con_extint1	
+	str	r2, [r1, #oEXTINT1]
+	ldr	r2, gpio_con_extint2	
+	str	r2, [r1, #oEXTINT2]
+
+	@ Init NAND 
+
+	@ Write the timing
+	mov  	r1, #NAND_CTL_BASE
+	ldr 	r2, =S3C2440_NAND_TIMING 
+	str	r2, [r1,  #oNFCONF]
+
+	@ Write the NCONT
+	mov 	r2, #S3C2440_NAND_CONF
+	str	r2, [r1,  #oNFCONT]
+
+	@ Write the NFSTAT
+	mov 	r2, #0
+	str 	r2, [r1, #oNFSTAT]
+
+	@ Reset the NAND
+	bl NF_nFCE_L
+	bl NF_CLEAR_RB
+	mov r2, #0xFF
+	str r2, [r1, #0x08]
+	bl NF_DETECT_RB
+	bl NF_nFCE_H
 
 	@ get read to call C functions
 	mov	fp, #0			@ no previous frame, so fp=0
 	mov	a2, #0			@ set argv to NULL 
-
-	bl	Main			
-
-1:	b	1b @
-
+	bl Main
+	
+	@ Call linux
+	mov	r0, #0
+	ldr	r1, =1999
+	ldr	r2, =0x30008000
+	mov	ip, #0
+	mov	pc, r2
 
 /*
  * subroutines
  */
+	
+
+NF_nFCE_H :
+	ldr	r2, [r1, #4]
+	orr	r2, r2, #2
+	str	r2, [r1, #4]
+	mov 	pc, lr
+
+NF_DETECT_RB :
+1: 	mov	r1, #0x4e000000
+	ldr	r2, [r1, #32]
+	tst	r2, #4
+	beq	1b
+	mov	pc, lr
+
+NF_CLEAR_RB :
+	mov 	r1, #0x4E000000
+	ldr	r2, [r1, #0x20]
+	orr	r2, r2, #(1<<2)
+	str	r2, [r1, #0x20]
+	mov	pc, lr
+
+NF_nFCE_L : 
+	mov 	r1, #0x4E000000
+	ldr	r2, [r1, #0x04]
+	bic	r2, r2, #2
+	str	r2, [r1, #0x04]
+	mov	pc, lr
 
 memsetup:
 	@ initialise the static memory 
@@ -174,6 +189,86 @@ memsetup:
 	bne	1b
 	mov	pc, lr
 
+	.global	NandReadOneSectorP2048
+	.type	NandReadOneSectorP2048, %function
+	
+NandReadOneSectorP2048:
+	stmfd	sp!, {fp, lr}
+	add	fp, sp, #4
+	sub	sp, sp, #16
+	str	r0, [fp, #-16]
+	str	r1, [fp, #-20]
+	ldr	r3, [fp, #-20]
+	mov	r3, r3, lsr #11
+	str	r3, [fp, #-8]
+	bl 	NF_nFCE_L
+	bl 	NF_CLEAR_RB
+	
+	@ Commande 0x00
+	mov	r1, #0x4e000000
+	mov 	r2, #0x00
+	str 	r2, [r1, #0x08]
+	
+	@ Addr 0x00
+	mov	r1, #0x4e000000
+	mov 	r2, #0x00
+	str 	r2, [r1, #0x08]
+	
+	@ Addresse avec les secteurs, à modifier ! 
+	
+	ldr	r3, .L3+12
+	mov	r2, #0
+	str	r2, [r3, #0]
+	ldr	r3, .L3+12
+	mov	r2, #0
+	str	r2, [r3, #0]
+	ldr	r3, .L3+12
+	ldr	r2, [fp, #-8]
+	and	r2, r2, #255
+	str	r2, [r3, #0]
+	ldr	r3, .L3+12
+	ldr	r2, [fp, #-8]
+	mov	r2, r2, lsr #8
+	and	r2, r2, #255
+	str	r2, [r3, #0]
+	ldr	r3, .L3+12
+	ldr	r2, [fp, #-8]
+	mov	r2, r2, lsr #16
+	and	r2, r2, #255
+	str	r2, [r3, #0]
+	ldr	r3, .L3+8
+	mov	r2, #48
+	str	r2, [r3, #0]
+	bl NF_DETECT_RB
+	ldr	r0, [fp, #-16]
+	ldr	r1, .L3+16
+	bl	ReadPage512
+	ldr	r3, [fp, #-16]  @ On récupère l'adresse du buffer
+	add	r3, r3, #512 	@ L'incrémentation du buffer
+	mov	r0, r3		@ On met la valeur du buffer dans r0 
+	ldr	r1, .L3+16	@ On récupère l'adresse de NFDATA dans r1 
+	bl	ReadPage512
+	ldr	r3, [fp, #-16]
+	add	r3, r3, #1024
+	mov	r0, r3
+	ldr	r1, .L3+16
+	bl	ReadPage512
+	ldr	r3, [fp, #-16]
+	add	r3, r3, #1536
+	mov	r0, r3
+	ldr	r1, .L3+16
+	bl	ReadPage512
+	bl 	NF_nFCE_H
+	sub	sp, fp, #4
+	ldmfd	sp!, {fp, lr}
+	bx	lr
+.L3:
+	.word	1308622852
+	.word	1308622880
+	.word	1308622856
+	.word	1308622860
+	.word	1308622864
+	.size	NandReadOneSectorP2048, .-NandReadOneSectorP2048
 
 	.globl ReadPage512
 
@@ -181,36 +276,41 @@ ReadPage512:
 	stmfd	sp!, {r2-r7}
 	mov	r2, #0x200
 1:
+	@ UTILISATION de LDM et STM
+	@ LDM     r0!, {r4-r11}            ; Load 8 words from the source
+   	@ STM     r1!, {r4-r11}            ; and put them at the destination
+    
+	ldr	r4, [r1]     // On charge un mot (32 bits) contenu à l'adresse  NFDATA (registre r1)
+	ldr	r5, [r1]     // On charge un mot (32 bits) contenu à l'adresse  NFDATA (registre r1)
+	ldr	r6, [r1]     // On charge un mot (32 bits) contenu à l'adresse  NFDATA (registre r1)
+	ldr	r7, [r1]     // On charge un mot (32 bits) contenu à l'adresse  NFDATA (registre r1)
+	stm	r0!, {r4-r7} // On charge un mot (32 bits) contenu à l'adresse  NFDATA (registre r1)
 	ldr	r4, [r1]
 	ldr	r5, [r1]
 	ldr	r6, [r1]
 	ldr	r7, [r1]
-	stmia	r0!, {r4-r7}
+	stm	r0!, {r4-r7}
 	ldr	r4, [r1]
 	ldr	r5, [r1]
 	ldr	r6, [r1]
 	ldr	r7, [r1]
-	stmia	r0!, {r4-r7}
+	stm	r0!, {r4-r7}
 	ldr	r4, [r1]
 	ldr	r5, [r1]
 	ldr	r6, [r1]
 	ldr	r7, [r1]
-	stmia	r0!, {r4-r7}
-	ldr	r4, [r1]
-	ldr	r5, [r1]
-	ldr	r6, [r1]
-	ldr	r7, [r1]
-	stmia	r0!, {r4-r7}
+	stm	r0!, {r4-r7}
 	subs	r2, r2, #64
 	bne	1b;
 	ldmfd	sp!, {r2-r7}
 	mov	pc,lr
 
+
 @ Initialize UART
 @
 @ r0 = number of UART port
 InitUART:
-	ldr	r1, SerBase
+	mov	r1, #UART0_CTL_BASE
 	mov	r2, #0x0
 	str	r2, [r1, #oUFCON]
 	str	r2, [r1, #oUMCON]
@@ -218,27 +318,14 @@ InitUART:
 	str	r2, [r1, #oULCON]
 	ldr	r2, =0x245
 	str	r2, [r1, #oUCON]
-
-//#define UART_BAUD_RATE		115200
-//#define UART_PCLK_400_148    	50000000
-//#define UART_PCLK           UART_PCLK_400_148
-#define UART_BRD ((UART_PCLK  / (UART_BAUD_RATE * 16)) - 1)
 	mov	r2, #UART_BRD
 	str	r2, [r1, #oUBRDIV]
-
 	mov	r3, #100
 	mov	r2, #0x0
 1:	sub	r3, r3, #0x1
 	tst	r2, r3
 	bne	1b
-
 	mov	pc, lr
-
-
-IRQHandle:
-	ldr	pc, =0x33f00000+0x18
-	nop
-	nop
 	
 @
 @ Data Area
@@ -282,11 +369,22 @@ gpio_con_uart:
 	.long	vGPHCON
 gpio_up_uart:
 	.long	vGPHUP
+@ inital values for ADC
+gpio_con_adc:
+	.long	vGPCCON
+gpio_up_adc:
+	.long	vGPCUP
+
+gpio_con_extint0:
+	.long	vEXTINT0
+gpio_con_extint1:
+	.long	vEXTINT1
+gpio_con_extint2:
+	.long	vEXTINT2
 
-	.align	2
+.align	2
 DW_STACK_START:
 	.word	0x34000000-4
 
-.align 4
-SerBase:
-	.long UART0_CTL_BASE
+
+
diff -rupN ../../Archives/vboot_20100106/vboot/head.h vboot//head.h
--- vboot/head.h	1970-01-01 00:00:00.000000000 +0000
+++ vboot//head.h	2011-12-22 16:35:42.046480460 +0000
@@ -0,0 +1,131 @@
+/*
+ * s3c2440 head.h:
+ *   Initialise hardware
+ * 
+ * Copyright (C) 2011 Théou Jean-Baptiste 
+ * Copyright (C) 2001 MIZI Research, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License 
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * Author: Théou Jean-Baptiste <jbtheou@gmail.com>
+ * Date  : $Date: 2011-11-23 11:00:10 $
+ *
+ * $Revision: 2.0$
+ *
+ *
+ * History:
+ * 2007-07-03: Janghoon Lyu <nandy@mizi.com>
+ * 	 - Revision 1.2		
+ * 2002-05-14: Janghoon Lyu <nandy@mizi.com>
+ *   - Initial code
+ *
+ */
+
+// Timing de Nand
+#define TACLS			0	
+#define TWRPH0			1
+#define TWRPH1			0
+
+// Configuration de la nand
+#define S3C2440_NAND_TIMING 	((TACLS << 12) | (TWRPH0 << 8) | (TWRPH1 << 4) | (0 << 0))
+#define S3C2440_NAND_CONF   	((0 << 13) | (0 << 12) | (0 << 10) | (0 << 9) | (0 << 8) | (0 << 6) | (0 << 5) | (1 << 4) | (1 << 1) | (1 << 0))
+
+// Configuration de la clock
+#define S3C2440_UPLL_48MHZ_Fin12MHz     ((0x38<<12)|(0x02<<4)|(0x02))
+
+// UART
+#define UART_BAUD_RATE	    	115200
+#define UART_PCLK	    	53100000
+#define UART_BRD 	    	((UART_PCLK  / (UART_BAUD_RATE * 16)) - 1)
+
+// Memory Map 
+#define INT_CTL_BASE		0x4A000000 // Interruption
+#define CLK_CTL_BASE		0x4C000000 // Clock
+#define GPIO_CTL_BASE		0x56000000 // GPIO
+#define NAND_CTL_BASE		0x4E000000 // Nand
+#define MEM_CTL_BASE		0x48000000 // Memory
+
+// Offset
+#define oGPIO_H			0x70 // Offset H port
+#define oGPIO_C			0x20 // Offset C port
+#define oINTMSK			0x08 // Interruption Mask
+#define oINTSUBMSK		0x1C // Interruption subMask
+#define oLOCKTIME		0x00 // R/W, PLL lock time count register
+#define oCLKDIVN		0x14 // R/W, Clock divider control
+#define oUPLLCON		0x08 // R/W, UPLL configuration register 
+#define oMPLLCON		0x04 // R/W, MPLL configuration register
+#define oGPIO_CON		0x00 // R/W, Configures the pins of the port
+#define oGPIO_UP		0x08 // R/W, Pull-up disable register
+#define oEXTINT0		0x88 // R/W, External interrupt control reg. 0 
+#define oEXTINT1		0x8C // R/W, External interrupt control reg. 1 
+#define oEXTINT2		0x90 // R/W, External interrupt control reg. 2 
+#define oNFCONF			0x00
+#define oNFCONT			0x04
+#define oNFSTAT			0x20
+#define oULCON			0x00 // R/W, UART line control register 
+#define oUCON			0x04 // R/W, UART control register 
+#define oUFCON			0x08 // R/W, UART FIFO control register 
+#define oUMCON			0x0C // R/W, UART modem control register
+#define oUBRDIV			0x28 // R/W, Baud rate divisor register 
+
+
+// Constante 
+
+// SDRAM
+#define vBWSCON			0x22111110
+#define vBANKCON0		0x00000400 
+#define vBANKCON1		0x00000400
+#define vBANKCON2		0x00000400 
+#define vBANKCON3		0x00000400 
+#define vBANKCON4		0x00000400 
+#define vBANKCON5		0x00000400 
+// RAM
+#define vBANKCON6		0x00018009 
+#define vBANKCON7		0x00018009
+#define vBANKSIZE		0x92
+#define vMRSRB6			0x30
+#define vMRSRB7			0x30
+// Refresh con
+#define vREFRESH            	0x008704EB		
+
+// Clock 
+#define vCLKDIVN_NOW        	0x05		// 1:4:8
+#define vMPLLCON_NOW_USER   	((169 << 12) + (0x3 << 4) + 0x1)
+
+// Serial 
+#define vULCON			0x03	// UART, no parity, one stop bit, 8 bits 
+#define vUCON			0x0245
+#define vUFCON			0x00
+#define vUMCON			0x00
+#define UART_CTL_BASE		0x50000000
+#define UART0_CTL_BASE		UART_CTL_BASE
+
+// GPIO
+#define vGPCCON			0xaaaaaaaa
+#define vGPCUP			0x0000ffff
+#define vGPHCON			0x0016faaa
+#define vGPHUP			0x000007ff
+#define vEXTINT0		0x22222222
+#define vEXTINT1		0x22222222
+#define vEXTINT2		0x22222222
+
+// Nand alignement 
+#define BYTE_SECTOR_SHIFT   	11
+#define SECTOR_BLOCK_SHIFT   	6
+#define SECTOR_SIZE 		(1 << BYTE_SECTOR_SHIFT)
+#define BLOCK_SIZE  		(SECTOR_SIZE << SECTOR_BLOCK_SHIFT)
+
+
diff -rupN ../../Archives/vboot_20100106/vboot/main.c vboot//main.c
--- vboot/main.c	2011-12-22 17:11:57.711280907 +0000
+++ vboot//main.c	2011-12-22 17:04:24.095951878 +0000
@@ -3,171 +3,37 @@
 ************************************************/
 //#include <stdlib.h>
 //#include <string.h>
-#include "def.h"
-#include "nand.h"
-#include "244x_lib.h"
-#include "s3c2440.h"
 
-#include "parameters.h"
+//#include "nand.h"
+//#include "s3c2440.h"
 
-static inline void MMU_EnableICache(void)
-{
-
-	asm (
-		"mrc p15,0,r0,c1,c0,0\n"
-		"orr r0,r0,#(1<<12)\n"
-		"mcr p15,0,r0,c1,c0,0\n"
-	);
-}
-
-static inline void MMU_EnableDCache(void)
-{
-	asm (
-		"mrc p15,0,r0,c1,c0,0\n"
-		"orr r0,r0,#(1<<2)\n"
-		"mcr p15,0,r0,c1,c0,0\n"
-	);
-}
+#include "head.h"
 
-static void CallLinux(void)
-{
-	struct param_struct {
-		union {
-			struct {
-				unsigned long page_size;	/*  0 */
-				unsigned long nr_pages;	/*  4 */
-				unsigned long ramdisk_size;	/*  8 */
-				unsigned long flags;	/* 12 */
-				unsigned long rootdev;	/* 16 */
-				unsigned long video_num_cols;	/* 20 */
-				unsigned long video_num_rows;	/* 24 */
-				unsigned long video_x;	/* 28 */
-				unsigned long video_y;	/* 32 */
-				unsigned long memc_control_reg;	/* 36 */
-				unsigned char sounddefault;	/* 40 */
-				unsigned char adfsdrives;	/* 41 */
-				unsigned char bytes_per_char_h;	/* 42 */
-				unsigned char bytes_per_char_v;	/* 43 */
-				unsigned long pages_in_bank[4];	/* 44 */
-				unsigned long pages_in_vram;	/* 60 */
-				unsigned long initrd_start;	/* 64 */
-				unsigned long initrd_size;	/* 68 */
-				unsigned long rd_start;	/* 72 */
-				unsigned long system_rev;	/* 76 */
-				unsigned long system_serial_low;	/* 80 */
-				unsigned long system_serial_high;	/* 84 */
-				unsigned long mem_fclk_21285;	/* 88 */
-			} s;
-			char unused[256];
-		} u1;
-		union {
-			char paths[8][128];
-			struct {
-				unsigned long magic;
-				char n[1024 - sizeof(unsigned long)];
-			} s;
-		} u2;
-		char commandline[1024];
-	};
-
-	struct param_struct *p = (struct param_struct *)0x30000100;
-	memset(p, 0, sizeof(*p));
-	memcpy(p->commandline, g_linux_cmd_line, sizeof(g_linux_cmd_line));
-	p->u1.s.page_size = 4 * 1024;
-	p->u1.s.nr_pages = 64 * 1024 * 1024 / (4 * 1024);
-
-	{
-		unsigned int *pp = (unsigned int *)(0x30008024);
-		if (pp[0] == 0x016f2818) {  // Magic number of zImage
-			//Uart_SendString("\n\rOk\n\r");
-		} else {
-			Uart_SendString("\n\rWrong Linux Kernel\n\r");
-			for (;;) ;
-		}
+extern void ReadPage512(unsigned char * buf, volatile unsigned char *nf_data_ptr);
 
-	}
- 	asm (
-		"mov	r0, %0\n"
-		"mov	r1, %1\n"
-		"mov	r2, %2\n"
-		"mov	ip, #0\n"
-		"mov	pc, r2\n"
-		"nop\n" "nop\n":	/* no outpus */
-		:"r"(0), "r"(1999), "r"(g_os_ram_start)
-	);
-}
 
 void ReadImageFromNand(void)
 {
-	unsigned int Length;
-	U8 *RAM;
-	unsigned BlockNum;
-	unsigned pos;
-
-	Length = g_os_length;
-	Length = (Length + BLOCK_SIZE - 1) >> (BYTE_SECTOR_SHIFT + SECTOR_BLOCK_SHIFT) << (BYTE_SECTOR_SHIFT + SECTOR_BLOCK_SHIFT); // align to Block Size
-
-	BlockNum = g_os_start >> (BYTE_SECTOR_SHIFT + SECTOR_BLOCK_SHIFT);
-	RAM = (U8 *) g_os_ram_start;
-	for (pos = 0; pos < Length; pos += BLOCK_SIZE) {
-		unsigned int i;
-		// skip badblock
-		for (;;) {
-			if (NandIsGoodBlock
-			    (BlockNum <<
-			     (BYTE_SECTOR_SHIFT + SECTOR_BLOCK_SHIFT))) {
-				break;
-			}
-			BlockNum++;	//try next
-		}
-		for (i = 0; i < BLOCK_SIZE; i += SECTOR_SIZE) {
-			int ret =
-			    NandReadOneSector(RAM,
-					      (BlockNum <<
-					       (BYTE_SECTOR_SHIFT +
-						SECTOR_BLOCK_SHIFT)) + i);
+	unsigned int pos;
+	unsigned int i;
+	unsigned char * RAM = (unsigned char *)0x30008000;
+	unsigned int BlockNum = (0x60000 >> (BYTE_SECTOR_SHIFT + SECTOR_BLOCK_SHIFT));
+	// Utiliser test.c pour mettre à jour 
+	for (pos = 0; pos < 13; pos += 1) {
+			for (i = 0; i < 64; i += 1) {
+			NandReadOneSectorP2048(RAM,(BlockNum <<(BYTE_SECTOR_SHIFT + SECTOR_BLOCK_SHIFT)) + i*SECTOR_SIZE);
 			RAM += SECTOR_SIZE;
-			ret = 0;
-
 		}
-
 		BlockNum++;
 	}
-
-	CallLinux();
-}
-
-static inline void GetParameters(void)
-{
-	U32 Buf[2048];
-	g_os_type = OS_LINUX;
-	g_os_start = 0x60000;
-	g_os_length = 0x500000;
-
-	g_os_ram_start = 0x30008000;
-
-	// vivi LINUX CMD LINE
-	NandReadOneSector((U8 *)Buf, 0x48000);
-	if (Buf[0] == 0x49564956 && Buf[1] == 0x4C444D43) {
-		memcpy(g_linux_cmd_line, (char *)&(Buf[2]), sizeof g_linux_cmd_line);
+	for(i=0; i < 20; i+=1){
+			NandReadOneSectorP2048(RAM,(BlockNum <<(BYTE_SECTOR_SHIFT + SECTOR_BLOCK_SHIFT)) + i*SECTOR_SIZE);
+			RAM += SECTOR_SIZE;
 	}
+	// Pour la version sans printk (avec 14 dans la boucle)
 }
 
 void Main(void)
 {
-	MMU_EnableICache();
-	MMU_EnableDCache();
-
-	Port_Init();
-	NandInit();
-
-	if (g_page_type == PAGE_UNKNOWN) {
-		Uart_SendString("\r\nunsupport NAND\r\n");
-		for(;;);
-	}
-
-	GetParameters();
-
-	Uart_SendString("load Image of Linux...\n\r");
 	ReadImageFromNand();
 }
diff -rupN ../../Archives/vboot_20100106/vboot/nand.c vboot//nand.c
--- vboot/nand.c	2011-12-22 17:11:57.714280871 +0000
+++ vboot//nand.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,268 +0,0 @@
-#include "def.h"
-#include "s3c2440.h"
-#include "nand.h"
-#include "parameters.h"
-
-#define NF_MECC_UnLock()    {NFCONT&=~(1<<5);}
-#define NF_MECC_Lock()      {NFCONT|=(1<<5);}
-
-#define NF_CMD(cmd)			{NFCMD=cmd;}
-#define NF_ADDR(addr)		{NFADDR=addr;}
-#define NF_nFCE_L()			{NFCONT&=~(1<<1);}
-#define NF_nFCE_H()			{NFCONT|=(1<<1);}
-#define NF_RSTECC()			{NFCONT|=(1<<4);}
-#define NF_RDDATA8() 		(NFDATA)
-
-#define NF_WAITRB()    		{while(!(NFSTAT&(1<<1)));}
-							 //wait tWB and check F_RNB pin.
-// RnB Signal
-#define NF_CLEAR_RB()    	{NFSTAT |= (1<<2);}	// Have write '1' to clear this bit.
-#define NF_DETECT_RB()    	{while(!(NFSTAT&(1<<2)));}
-
-#define TACLS		0	// 1-clk(0ns)
-#define TWRPH0		6	// 3-clk(25ns)
-#define TWRPH1		2	// 1-clk(10ns)  //TACLS+TWRPH0+TWRPH1>=50ns
-
-
-#define ECC_VERIFY	0
-
-int g_page_type = PAGE_UNKNOWN;
-
-extern void ReadPage512(U8* buf, volatile unsigned char *nf_data_ptr);
-
-static inline void NandReset(void)
-{
-	NF_nFCE_L();
-	NF_CLEAR_RB();
-	NF_CMD(0xFF);		//reset command
-	NF_DETECT_RB();
-	NF_nFCE_H();
-
-}
-
-static inline void delay(void)
-{
-#if 0
-	volatile int i;
-	for (i = 0; i < 1000; i++);
-#endif
-}
-
-static inline U32 NandCheckId(void)
-{
-	U8 Mid, Did, DontCare, id4th;
-
-	NF_nFCE_L();
-
-	NF_CMD(0x90);
-	NF_ADDR(0x0);
-
-	delay();
-
-	Mid = NF_RDDATA8();
-	Did = NF_RDDATA8();
-	DontCare = NF_RDDATA8();
-	id4th = NF_RDDATA8();
-
-	NF_nFCE_H();
-
-	switch(Did) {
-	case 0x76:
-		g_page_type = PAGE512;
-		break;
-	case 0xF1:
-	case 0xD3:
-	case 0xDA:
-	case 0xDC:
-		g_page_type = PAGE2048;
-		break;
-	default:
-		;
-	}
-
-	return (U32) ((Mid << 24) | (Did << 16) | (DontCare << 8) | id4th);
-}
-
-void NandInit(void)
-{
-	NFCONF = (TACLS << 12) | (TWRPH0 << 8) | (TWRPH1 << 4) | (0 << 0);
-	NFCONT =
-	    (0 << 13) | (0 << 12) | (0 << 10) | (0 << 9) | (0 << 8) | (0 << 6) |
-	    (0 << 5) | (1 << 4) | (1 << 1) | (1 << 0);
-	NFSTAT = 0;
-	NandReset();
-	NandCheckId();
-}
-
-static inline int NandIsGoodBlockP512(U32 addr)
-{
-	U32 sector = addr >> 9;
-	U8 bad_value;
-
-	NandReset();
-	NF_nFCE_L();
-	NF_CLEAR_RB();
-	NF_CMD(0x50);
-	NF_ADDR(5);
-	NF_ADDR(sector & 0xff);
-	NF_ADDR((sector >> 8) & 0xff);
-	NF_ADDR((sector >> 16) & 0xff);
-
-	delay();
-	NF_DETECT_RB();
-
-	bad_value = NF_RDDATA8();
-
-	NF_nFCE_H();
-
-	if (bad_value == 0xFF) {
-		return 1;
-	}
-
-	return 0;
-}
-
-static inline int NandIsGoodBlockP2048(U32 addr)
-{
-	U32 sector = addr >> 11;
-	U8 bad_value;
-
-	NandReset();
-	NF_nFCE_L();
-	NF_CLEAR_RB();
-	NF_CMD(0x0);
-	NF_ADDR(2048 & 0xFF);
-	NF_ADDR((2048 >>8) & 0xff);
-	NF_ADDR(sector & 0xff);
-	NF_ADDR((sector >> 8) & 0xff);
-	NF_ADDR((sector >> 16) & 0xff);
-	NF_CMD(0x30);
-	delay();
-	NF_DETECT_RB();
-
-	bad_value = NF_RDDATA8();
-
-	NF_nFCE_H();
-
-	if (bad_value == 0xFF) {
-		return 1;
-	}
-
-	return 0;
-}
-
-int NandIsGoodBlock(U32 addr)
-{
-	int ret;
-	
-	switch(g_page_type) {
-	case PAGE512:
-		{
-			unsigned int i;
-			// for ugly method of Chen Yongqiang
-			for (i = 0; i < 128 * 1024; i+= 16 * 1024) {
-				ret = NandIsGoodBlockP512(addr / (128 * 1024) * (128 * 1024) + i );
-				if (!ret) {
-					break;
-				}
-			}
-		}
-		break;
-	case PAGE2048:
-		ret = NandIsGoodBlockP2048(addr);
-		break;
-	default:
-		for(;;);
-	}
-	return ret;
-}
-
-static inline int NandReadOneSectorP512(U8 * buffer, U32 addr)
-{
-	U32 sector;
-	sector = addr >> 9;
-
-	NandReset();
-#if 0
-	NF_RSTECC();
-	NF_MECC_UnLock();
-#endif
-	NF_nFCE_L();
-
-	NF_CLEAR_RB();
-	NF_CMD(0x00);
-
-	NF_ADDR(0x00);
-	NF_ADDR(sector & 0xff);
-	NF_ADDR((sector >> 8) & 0xff);
-	NF_ADDR((sector >> 16) & 0xff);
-
-	delay();
-	NF_DETECT_RB();
-
-	ReadPage512(buffer, &NFDATA);
-#if 0
-	NF_MECC_Lock();
-#endif
-	NF_nFCE_H();
-
-	return 1;
-}
-
-
-static inline int NandReadOneSectorP2048(U8 * buffer, U32 addr)
-{
-	U32 sector;
-	sector = addr >> 11;
-
-	delay();
-	NandReset();
-#if 0
-	NF_RSTECC();
-	NF_MECC_UnLock();
-#endif
-	NF_nFCE_L();
-
-	NF_CLEAR_RB();
-	NF_CMD(0x00);
-
-	NF_ADDR(0x00);
-	NF_ADDR(0x00);
-	NF_ADDR(sector & 0xff);
-	NF_ADDR((sector >> 8) & 0xff);
-	NF_ADDR((sector >> 16) & 0xff);
-	NF_CMD(0x30);
-
-	delay();
-	NF_DETECT_RB();
-
-	ReadPage512(buffer + 0 * 512, &NFDATA);
-	ReadPage512(buffer + 1 * 512, &NFDATA);
-	ReadPage512(buffer + 2 * 512, &NFDATA);
-	ReadPage512(buffer + 3 * 512, &NFDATA);
-
-#if 0
-	NF_MECC_Lock();
-#endif
-	NF_nFCE_H();
-
-	return 1;
-}
-
-
-int NandReadOneSector(U8 * buffer, U32 addr)
-{
-	int ret;
-	
-	switch(g_page_type) {
-	case PAGE512:
-		ret = NandReadOneSectorP512(buffer, addr);
-		break;
-	case PAGE2048:
-		ret = NandReadOneSectorP2048(buffer, addr);
-		break;
-	default:
-		for(;;);
-	}
-	return ret;
-}
diff -rupN ../../Archives/vboot_20100106/vboot/nand.h vboot//nand.h
--- vboot/nand.h	2011-12-22 17:11:57.715280859 +0000
+++ vboot//nand.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,22 +0,0 @@
-#ifndef __NAND_H
-#define __NAND_H
-
-void NandInit(void);
-int NandIsGoodBlock(U32 addr);
-int NandReadOneSector(U8 * buffer, U32 addr);
-
-void Uart_SendString(char *);
-
-#define PAGE_UNKNOWN 0
-#define PAGE512      1
-#define PAGE2048     2
-
-#define BYTE_SECTOR_SHIFT   (g_page_type == PAGE512 ? 9 : 11)
-#define SECTOR_BLOCK_SHIFT  (g_page_type == PAGE512 ? 5 : 6)
-
-#define SECTOR_SIZE (1 << BYTE_SECTOR_SHIFT)
-#define BLOCK_SIZE  (SECTOR_SIZE << SECTOR_BLOCK_SHIFT)
-
-extern int g_page_type;
-
-#endif /*__NAND_H*/
diff -rupN ../../Archives/vboot_20100106/vboot/parameters.h vboot//parameters.h
--- vboot/parameters.h	2011-12-22 17:11:57.716280846 +0000
+++ vboot//parameters.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,51 +0,0 @@
-
-
-#undef LINUX_CMD_LINE
-#define LINUX_CMD_LINE "noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0"
-
-//#undef LINUX_CMD_LINE
-//#define LINUX_CMD_LINE "console=ttySAC0 root=/dev/nfs nfsroot=192.168.1.99:/opt/FriendlyARM/mini2440/new_root_nfs ip=192.168.1.30:192.168.1.99:192.168.1.1:255.255.255.0:sbc2440.arm9.net:eth0:off"
-
-#define OS_LINUX 0x02
-#define OS_WINCE 0x04
-
-#if 1
-#define OS_TYPE		OS_LINUX
-#define HAS_NAND_BIOS	0xFF
-#define LOGO_POS	0xFFFF
-#define OS_START	0x60000
-#define OS_LENGTH	0x500000
-#define OS_RAM_START	0x30008000
-
-#else
-#define OS_TYPE		OS_WINCE
-#define HAS_NAND_BIOS	0xFF
-#define LOGO_POS	0xFFFF
-#define OS_START	(0xb00 * 512)
-#define OS_LENGTH	(0x1E00000)
-#define OS_RAM_START	0x30200000
-#endif
-#define ZBOOT_MAGIC	0x19710829
-#if !defined(__ASSEMBLY__)
-extern  struct zboot_first_sector {
-	unsigned char  dont_care[0x20];
-	unsigned int   magic;
-	unsigned char  os_type;
-	unsigned char  has_nand_bios;
-	unsigned short logo_pos;
-	unsigned int   os_start;
-	unsigned int   os_length;
-	unsigned int   os_ram_start;
-	unsigned char  linux_cmd[512 - 0x34];
-}  __attribute__((packed)) first_sector;
-
-#define g_magic			(first_sector.magic)
-#define g_os_type		(first_sector.os_type)
-#define g_has_nand_bios		(first_sector.has_nand_bios)
-#define g_logo_pos		(first_sector.logo_pos)
-#define g_os_start		(first_sector.os_start)
-#define g_os_length		(first_sector.os_length)
-#define g_os_ram_start		(first_sector.os_ram_start)
-#define g_linux_cmd_line	(first_sector.linux_cmd)
-
-#endif
diff -rupN ../../Archives/vboot_20100106/vboot/s3c2440.h vboot//s3c2440.h
--- vboot/s3c2440.h	2011-12-22 17:11:57.719280807 +0000
+++ vboot//s3c2440.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,469 +0,0 @@
-/*
- * vivi/include/s3c2440.h
- *
- * Definition of constants related to the S3C2410 microprocessor(based on ARM 290T).
- * This file is based on the S3C2400 User Manual 2002,01,23.
- *
- * Copyright (C) 2002 MIZI Research, Inc.
- *
- *  Author: Janghoon Lyu <nandy@mizi.com>
- *  Date  : $Date: 2007-01-27 18:33:49 $
- *
- *  $Revision: 1.1.1.1 $
- */
-
-/*
- * History
- * 
- * 2002-05-14: Janghoon Lyu <nandy@mizi.com>
- *    - Initial code
- */
-
-#include "hardware.h"
-#include "bitfield.h"
-
-#define USR26_MODE		0x00
-#define FIQ26_MODE		0x01
-#define IRQ26_MODE		0x02
-#define SVC26_MODE		0x03
-#define USR_MODE		0x10
-#define FIQ_MODE		0x11
-#define IRQ_MODE		0x12
-#define SVC_MODE		0x13
-#define ABT_MODE		0x17
-#define UND_MODE		0x1b
-#define SYSTEM_MODE		0x1f
-#define MODE_MASK		0x1f
-#define F_BIT			0x40
-#define I_BIT			0x80
-#define CC_V_BIT		(1 << 28)
-#define CC_C_BIT		(1 << 29)
-#define CC_Z_BIT		(1 << 30)
-#define CC_N_BIT		(1 << 31)
-
-/* Register 1. Control Register */
-#define R1_nF			(1 << 30)
-#define R1_iA			(1 << 31)
-
-/* Memory Controller */
-#define MEM_CTL_BASE		0x48000000
-#define bMEMCTL(Nb)		__REGl(MEM_CTL_BASE + (Nb))
-/* Offset */
-#define oBWSCON			0x00	/* R/W, Bus width and wait status ctrl reg. */
-#define oBANKCON0		0x04	/* R/W, Bank 0 control reg. */
-#define oBANKCON1		0x08	/* R/W, Bank 1 control reg. */
-#define oBANKCON2		0x0C	/* R/W, Bank 2 control reg. */
-#define oBANKCON3		0x10	/* R/W, Bank 3 control reg. */
-#define oBANKCON4		0x14	/* R/W, Bank 4 control reg. */
-#define oBANKCON5		0x18	/* R/W, Bank 5 control reg. */
-#define oBANKCON6		0x1C	/* R/W, Bank 6 control reg. */
-#define oBANKCON7		0x20	/* R/W, Bank 7 control reg. */
-#define oREFRESH		0x24	/* R/W, SDRAM refresh control register */
-#define oBANKSIZE		0x28	/* R/W, Flexible bank size register */
-#define oMRSRB6			0x2C	/* R/W, Mode register set register bank 6 */
-#define oMRSRB7			0x2C	/* R/W, Mode register set register bank 7 */
-/* Registers */
-#define BWSCON			bMEMCTL(oBWSCON)
-#define BANKCON0		bMEMCTL(oBANKCON0)
-#define BANKCON1		bMEMCTL(oBANKCON1)
-#define BANKCON2		bMEMCTL(oBANKCON2)
-#define BANKCON3		bMEMCTL(oBANKCON3)
-#define BANKCON4		bMEMCTL(oBANKCON4)
-#define BANKCON5		bMEMCTL(oBANKCON5)
-#define BANKCON6		bMEMCTL(oBANKCON6)
-#define BANKCON7		bMEMCTL(oBANKCON7)
-#define REFRESH			bMEMCTL(oREFRESH)
-#define BANKSIZE		bMEMCTL(oBANKSIZE)
-#define MRSRB6			bMEMCTL(oMRSRB6)
-#define MRSRB7			bMEMCTL(oMRSRB7)
-/* Bits */
-#define SELF_REFRESH		(1 << 22)
-
-/* Clock and Power Management */
-#define CLK_CTL_BASE		0x4C000000
-#define bCLKCTL(Nb)		__REGl(CLK_CTL_BASE + (Nb))
-/* Offset */
-#define oLOCKTIME		0x00	/* R/W, PLL lock time count register */
-#define oMPLLCON		0x04	/* R/W, MPLL configuration register */
-#define oUPLLCON		0x08	/* R/W, UPLL configuration register */
-#define oCLKCON			0x0C	/* R/W, Clock generator control reg. */
-#define oCLKSLOW		0x10	/* R/W, Slow clock control register */
-#define oCLKDIVN		0x14	/* R/W, Clock divider control */
-/* Registers */
-#define LOCKTIME		bCLKCTL(oLOCKTIME)
-#define MPLLCON			bCLKCTL(oMPLLCON)
-#define UPLLCON			bCLKCTL(oUPLLCON)
-#define CLKCON			bCLKCTL(oCLKCON)
-#define CLKSLOW			bCLKCTL(oCLKSLOW)
-#define CLKDIVN			bCLKCTL(oCLKDIVN)
-/* Fields */
-#define fMPLL_MDIV		Fld(8,12)
-#define fMPLL_PDIV		Fld(6,4)
-#define fMPLL_SDIV		Fld(2,0)
-/* macros */
-#define GET_MDIV(x)		FExtr(x, fMPLL_MDIV)
-#define GET_PDIV(x)		FExtr(x, fMPLL_PDIV)
-#define GET_SDIV(x)		FExtr(x, fMPLL_SDIV)
-
-/* GPIO */
-#define GPIO_CTL_BASE		0x56000000
-#define bGPIO(p,o)		__REGl(GPIO_CTL_BASE + (p) + (o))
-/* Offset */
-#define oGPIO_CON		0x0	/* R/W, Configures the pins of the port */
-#define oGPIO_DAT		0x4	/* R/W, Data register for port */
-#define oGPIO_UP		0x8	/* R/W, Pull-up disable register */
-#define oGPIO_RESERVED		0xC	/* R/W, Reserved */
-#define oGPIO_A			0x00
-#define oGPIO_B			0x10
-#define oGPIO_C			0x20
-#define oGPIO_D			0x30
-#define oGPIO_E			0x40
-#define oGPIO_F			0x50
-#define oGPIO_G			0x60
-#define oGPIO_H			0x70
-#define oMISCCR			0x80	/* R/W, Miscellaneous control register */
-#define oDCLKCON		0x84	/* R/W, DCLK0/1 control register */
-#define oEXTINT0		0x88	/* R/W, External interrupt control reg. 0 */
-#define oEXTINT1		0x8C	/* R/W, External interrupt control reg. 1 */
-#define oEXTINT2		0x90	/* R/W, External interrupt control reg. 2 */
-#define oEINTFLT0		0x94	/* R/W, Reserved */
-#define oEINTFLT1		0x98	/* R/W, Reserved */
-#define oEINTFLT2		0x9C	/* R/W, External interrupt control reg. 2 */
-#define oEINTFLT3		0xA0	/* R/W, External interrupt control reg. 3 */
-#define oEINTMASK		0xA4	/* R/W, External interrupt mask register */
-#define oEINTPEND		0xA8	/* R/W, External interrupt pending reg. */
-/* Registers */
-#define GPACON			bGPIO(oGPIO_A, oGPIO_CON)
-#define GPADAT			bGPIO(oGPIO_A, oGPIO_DAT)
-#define GPBCON			bGPIO(oGPIO_B, oGPIO_CON)
-#define GPBDAT			bGPIO(oGPIO_B, oGPIO_DAT)
-#define GPBUP			bGPIO(oGPIO_B, oGPIO_UP)
-#define GPCCON			bGPIO(oGPIO_C, oGPIO_CON)
-#define GPCDAT			bGPIO(oGPIO_C, oGPIO_DAT)
-#define GPCUP			bGPIO(oGPIO_C, oGPIO_UP)
-#define GPDCON			bGPIO(oGPIO_D, oGPIO_CON)
-#define GPDDAT			bGPIO(oGPIO_D, oGPIO_DAT)
-#define GPDUP			bGPIO(oGPIO_D, oGPIO_UP)
-#define GPECON			bGPIO(oGPIO_E, oGPIO_CON)
-#define GPEDAT			bGPIO(oGPIO_E, oGPIO_DAT)
-#define GPEUP			bGPIO(oGPIO_E, oGPIO_UP)
-#define GPFCON			bGPIO(oGPIO_F, oGPIO_CON)
-#define GPFDAT			bGPIO(oGPIO_F, oGPIO_DAT)
-#define GPFUP			bGPIO(oGPIO_F, oGPIO_UP)
-#define GPGCON			bGPIO(oGPIO_G, oGPIO_CON)
-#define GPGDAT			bGPIO(oGPIO_G, oGPIO_DAT)
-#define GPGUP			bGPIO(oGPIO_G, oGPIO_UP)
-#define GPHCON			bGPIO(oGPIO_H, oGPIO_CON)
-#define GPHDAT			bGPIO(oGPIO_H, oGPIO_DAT)
-#define GPHUP			bGPIO(oGPIO_H, oGPIO_UP)
-#define MISCCR			bGPIO(oMISCCR, 0)
-#define DCLKCON			bGPIO(oDCLKCON, 0)
-#define EXTINT0			bGPIO(oEXTINT0, 0)
-#define EXTINT1			bGPIO(oEXTINT1, 0)
-#define EXTINT2			bGPIO(oEXTINT2, 0)
-#define EINTFLT0		bGPIO(oEINTFLT0, 0)
-#define EINTFLT1		bGPIO(oEINTFLT1, 0)
-#define EINTFLT2		bGPIO(oEINTFLT2, 0)
-#define EINTFLT3		bGPIO(oEINTFLT3, 0)
-#define EINTMASK		bGPIO(oEINTMASK, 0)
-#define EINTPEND		bGPIO(oEINTPEND, 0)
-
-/* UART */
-#define UART_CTL_BASE		0x50000000
-#define UART0_CTL_BASE		UART_CTL_BASE
-#define UART1_CTL_BASE		UART_CTL_BASE + 0x4000
-#define UART2_CTL_BASE		UART_CTL_BASE + 0x8000
-#define bUART(x, Nb)		__REGl(UART_CTL_BASE + (x)*0x4000 + (Nb))
-#define bUARTb(x, Nb)		__REGb(UART_CTL_BASE + (x)*0x4000 + (Nb))
-/* Offset */
-#define oULCON			0x00	/* R/W, UART line control register */
-#define oUCON			0x04	/* R/W, UART control register */
-#define oUFCON			0x08	/* R/W, UART FIFO control register */
-#define oUMCON			0x0C	/* R/W, UART modem control register */
-#define oUTRSTAT		0x10	/* R  , UART Tx/Rx status register */
-#define oUERSTAT		0x14	/* R  , UART Rx error status register */
-#define oUFSTAT			0x18	/* R  , UART FIFO status register */
-#define oUMSTAT			0x1C	/* R  , UART Modem status register */
-#define oUTXHL			0x20	/*   W, UART transmit(little-end) buffer */
-#define oUTXHB			0x23	/*   W, UART transmit(big-end) buffer */
-#define oURXHL			0x24	/* R  , UART receive(little-end) buffer */
-#define oURXHB			0x27	/* R  , UART receive(big-end) buffer */
-#define oUBRDIV			0x28	/* R/W, Baud rate divisor register */
-/* Registers */
-#define ULCON0			bUART(0, oULCON)
-#define UCON0			bUART(0, oUCON)
-#define UFCON0			bUART(0, oUFCON)
-#define UMCON0			bUART(0, oUMCON)
-#define UTRSTAT0		bUART(0, oUTRSTAT)
-#define UERSTAT0		bUART(0, oUERSTAT)
-#define UFSTAT0			bUART(0, oUFSTAT)
-#define UMSTAT0			bUART(0, oUMSTAT)
-#define UTXH0			bUARTb(0, oUTXHL)
-#define URXH0			bUARTb(0, oURXHL)
-#define UBRDIV0			bUART(0, oUBRDIV)
-#define ULCON1			bUART(1, oULCON)
-#define UCON1			bUART(1, oUCON)
-#define UFCON1			bUART(1, oUFCON)
-#define UMCON1			bUART(1, oUMCON)
-#define UTRSTAT1		bUART(1, oUTRSTAT)
-#define UERSTAT1		bUART(1, oUERSTAT)
-#define UFSTAT1			bUART(1, oUFSTAT)
-#define UMSTAT1			bUART(1, oUMSTAT)
-#define UTXH1			bUARTb(1, oUTXHL)
-#define URXH1			bUARTb(1, oURXHL)
-#define UBRDIV1			bUART(1, oUBRDIV)
-#define ULCON2			bUART(2, oULCON)
-#define UCON2			bUART(2, oUCON)
-#define UFCON2			bUART(2, oUFCON)
-#define UMCON2			bUART(2, oUMCON)
-#define UTRSTAT2		bUART(2, oUTRSTAT)
-#define UERSTAT2		bUART(2, oUERSTAT)
-#define UFSTAT2			bUART(2, oUFSTAT)
-#define UMSTAT2			bUART(2, oUMSTAT)
-#define UTXH2			bUARTb(2, oUTXHL)
-#define URXH2			bUARTb(2, oURXHL)
-#define UBRDIV2			bUART(2, oUBRDIV)
-/* ... */
-#define UTRSTAT_TX_EMPTY	(1 << 2)
-#define UTRSTAT_RX_READY	(1 << 0)
-#define UART_ERR_MASK		0xF
-
-/* Interrupts */
-#define INT_CTL_BASE		0x4A000000
-#define bINT_CTL(Nb)		__REG(INT_CTL_BASE + (Nb))
-/* Offset */
-#define oSRCPND			0x00
-#define oINTMOD			0x04
-#define oINTMSK			0x08
-#define oPRIORITY		0x0a
-#define oINTPND			0x10
-#define oINTOFFSET		0x14
-#define oSUBSRCPND		0x18
-#define oINTSUBMSK		0x1C
-/* Registers */
-#define SRCPND			bINT_CTL(oSRCPND)
-#define INTMOD			bINT_CTL(oINTMOD)
-#define INTMSK			bINT_CTL(oINTMSK)
-#define PRIORITY		bINT_CTL(oPRIORITY)
-#define INTPND			bINT_CTL(oINTPND)
-#define INTOFFSET		bINT_CTL(oINTOFFSET)
-#define SUBSRCPND		bINT_CTL(oSUBSRCPND)
-#define INTSUBMSK		bINT_CTL(oINTSUBMSK)
-
-#define INT_ADCTC		(1 << 31)	/* ADC EOC interrupt */
-#define INT_RTC			(1 << 30)	/* RTC alarm interrupt */
-#define INT_SPI1		(1 << 29)	/* UART1 transmit interrupt */
-#define INT_UART0		(1 << 28)	/* UART0 transmit interrupt */
-#define INT_IIC			(1 << 27)	/* IIC interrupt */
-#define INT_USBH		(1 << 26)	/* USB host interrupt */
-#define INT_USBD		(1 << 25)	/* USB device interrupt */
-#define INT_RESERVED24		(1 << 24)
-#define INT_UART1		(1 << 23)	/* UART1 receive interrupt */
-#define INT_SPI0		(1 << 22)	/* SPI interrupt */
-#define INT_MMC			(1 << 21)	/* MMC interrupt */
-#define INT_DMA3		(1 << 20)	/* DMA channel 3 interrupt */
-#define INT_DMA2		(1 << 19)	/* DMA channel 2 interrupt */
-#define INT_DMA1		(1 << 18)	/* DMA channel 1 interrupt */
-#define INT_DMA0		(1 << 17)	/* DMA channel 0 interrupt */
-#define INT_LCD			(1 << 16)	/* reserved for future use */
-#define INT_UART2		(1 << 15)	/* UART 2 interrupt  */
-#define INT_TIMER4		(1 << 14)	/* Timer 4 interrupt */
-#define INT_TIMER3		(1 << 13)	/* Timer 3 interrupt */
-#define INT_TIMER2		(1 << 12)	/* Timer 2 interrupt */
-#define INT_TIMER1		(1 << 11)	/* Timer 1 interrupt */
-#define INT_TIMER0		(1 << 10)	/* Timer 0 interrupt */
-#define INT_WDT			(1 << 9)	/* Watch-Dog timer interrupt */
-#define INT_TICK		(1 << 8)	/* RTC time tick interrupt  */
-#define INT_BAT_FLT		(1 << 7)
-#define INT_RESERVED6		(1 << 6)	/* Reserved for future use */
-#define INT_EINT8_23		(1 << 5)	/* External interrupt 8 ~ 23 */
-#define INT_EINT4_7		(1 << 4)	/* External interrupt 4 ~ 7 */
-#define INT_EINT3		(1 << 3)	/* External interrupt 3 */
-#define INT_EINT2		(1 << 2)	/* External interrupt 2 */
-#define INT_EINT1		(1 << 1)	/* External interrupt 1 */
-#define INT_EINT0		(1 << 0)	/* External interrupt 0 */
-
-#define INT_ADC			(1 << 10)
-#define INT_TC			(1 << 9)
-#define INT_ERR2		(1 << 8)
-#define INT_TXD2		(1 << 7)
-#define INT_RXD2		(1 << 6)
-#define INT_ERR1		(1 << 5)
-#define INT_TXD1		(1 << 4)
-#define INT_RXD1		(1 << 3)
-#define INT_ERR0		(1 << 2)
-#define INT_TXD0		(1 << 1)
-#define INT_RXD0		(1 << 0)
-
-/* NAND Flash Controller */
-#define NAND_CTL_BASE		0x4E000000
-#define bINT_CTL(Nb)		__REG(INT_CTL_BASE + (Nb))
-/* Offset */
-#define oNFCONF			0x00
-#define oNFCONT			0x04
-#define oNFCMD			0x08
-#define oNFADDR			0x0c
-#define oNFDATA			0x10
-#define oNFSTAT			0x20
-#define oNFECC			0x2c
-
-/* PWM Timer */
-#define bPWM_TIMER(Nb)          __REG(0x51000000 + (Nb))
-#define bPWM_BUFn(Nb,x)         bPWM_TIMER(0x0c + (Nb)*0x0c + (x))
-/* Registers */
-#define TCFG0                   bPWM_TIMER(0x00)
-#define TCFG1                   bPWM_TIMER(0x04)
-#define TCON                    bPWM_TIMER(0x08)
-#define TCNTB0                  bPWM_BUFn(0,0x0)
-#define TCMPB0                  bPWM_BUFn(0,0x4)
-#define TCNTO0                  bPWM_BUFn(0,0x8)
-#define TCNTB1                  bPWM_BUFn(1,0x0)
-#define TCMPB1                  bPWM_BUFn(1,0x4)
-#define TCNTO1                  bPWM_BUFn(1,0x8)
-#define TCNTB2                  bPWM_BUFn(2,0x0)
-#define TCMPB2                  bPWM_BUFn(2,0x4)
-#define TCNTO2                  bPWM_BUFn(2,0x8)
-#define TCNTB3                  bPWM_BUFn(3,0x0)
-#define TCMPB3                  bPWM_BUFn(3,0x4)
-#define TCNTO3                  bPWM_BUFn(3,0x8)
-#define TCNTB4                  bPWM_BUFn(4,0x0)
-#define TCNTO4                  bPWM_BUFn(4,0x4)
-/* Fields */
-#define fTCFG0_DZONE            Fld(8,16)	/* the dead zone length (= timer 0) */
-#define fTCFG0_PRE1             Fld(8,8)	/* prescaler value for time 2,3,4 */
-#define fTCFG0_PRE0             Fld(8,0)	/* prescaler value for time 0,1 */
-#define fTCFG1_MUX4		Fld(4,16)
-/* bits */
-#define TCFG0_DZONE(x)          FInsrt((x), fTCFG0_DZONE)
-#define TCFG0_PRE1(x)           FInsrt((x), fTCFG0_PRE1)
-#define TCFG0_PRE0(x)           FInsrt((x), fTCFG0_PRE0)
-#define TCON_4_AUTO             (1 << 22)	/* auto reload on/off for Timer 4 */
-#define TCON_4_UPDATE           (1 << 21)	/* manual Update TCNTB4 */
-#define TCON_4_ONOFF            (1 << 20)	/* 0: Stop, 1: start Timer 4 */
-#define COUNT_4_ON              (TCON_4_ONOFF*1)
-#define COUNT_4_OFF             (TCON_4_ONOFF*0)
-#define TCON_3_AUTO     (1 << 19)	/* auto reload on/off for Timer 3 */
-#define TIMER3_ATLOAD_ON        (TCON_3_AUTO*1)
-#define TIMER3_ATLAOD_OFF       FClrBit(TCON, TCON_3_AUTO)
-#define TCON_3_INVERT   (1 << 18)	/* 1: Inverter on for TOUT3 */
-#define TIMER3_IVT_ON   (TCON_3_INVERT*1)
-#define TIMER3_IVT_OFF  (FClrBit(TCON, TCON_3_INVERT))
-#define TCON_3_MAN      (1 << 17)	/* manual Update TCNTB3,TCMPB3 */
-#define TIMER3_MANUP    (TCON_3_MAN*1)
-#define TIMER3_NOP      (FClrBit(TCON, TCON_3_MAN))
-#define TCON_3_ONOFF    (1 << 16)	/* 0: Stop, 1: start Timer 3 */
-#define TIMER3_ON       (TCON_3_ONOFF*1)
-#define TIMER3_OFF      (FClrBit(TCON, TCON_3_ONOFF))
-/* macros */
-#define GET_PRESCALE_TIMER4(x)	FExtr((x), fTCFG0_PRE1)
-#define GET_DIVIDER_TIMER4(x)	FExtr((x), fTCFG1_MUX4)
-
-/*
- * NAND Flash Controller (Page 6-1 ~ 6-8)
- *
- * Register
-   NFCONF   NAND Flash Configuration    [word, R/W, 0x00000000]
-   NFCMD    NAND Flash Command Set      [word, R/W, 0x00000000]
-   NFADDR   NAND Flash Address Set      [word, R/W, 0x00000000]
-   NFDATA   NAND Flash Data             [word, R/W, 0x00000000]
-   NFSTAT   NAND Flash Status           [word, R, 0x00000000]
-   NFECC    NAND Flash ECC              [3 bytes, R, 0x00000000]
- *
- */
-#define bNAND_CTL(Nb)   __REG(0x4e000000 + (Nb))
-#define NFCONF          bNAND_CTL(0x00)
-#define NFCONT          bNAND_CTL(0x04)
-#define NFCMD       bNAND_CTL(0x08)
-#define NFADDR      bNAND_CTL(0x0c)
-#define NFDATA      __REGb(0x4e000000 + (0x10))
-#define NFSTAT      bNAND_CTL(0x20)
-#define NFECC       bNAND_CTL(0x2c)
-
-#define fNFCONF_TWRPH1   Fld(3,4)
-#define NFCONF_TWRPH1    FMsk(fNFCONF_TWRPH1)
-#define NFCONF_TWRPH1_7  FInsrt(0x7, fNFCONF_TWRPH1)	/* 7 */
-#define fNFCONF_TWRPH0   Fld(3,8)
-#define NFCONF_TWRPH0    FMsk(fNFCONF_TWRPH0)
-#define NFCONF_TWRPH0_7  FInsrt(0x7, fNFCONF_TWRPH0)	/* 7 */
-#define fNFCONF_TACLS    Fld(3,12)
-#define NFCONF_TACLS     FMsk(fNFCONF_TACLS)
-#define NFCONF_TACLS_7   FInsrt(0x7, fNFCONF_TACLS)	/* 7 */
-#define fNFCONT_nFCE     Fld(1,1)
-#define NFCONT_nFCE      FMsk(fNFCONT_nFCE)
-#define NFCONT_nFCE_LOW  FInsrt(0x0, fNFCONT_nFCE)	/* active */
-#define NFCONT_nFCE_HIGH FInsrt(0x1, fNFCONT_nFCE)	/* inactive */
-
-#define fNFCONT_ECC      Fld(1,4)
-#define NFCONT_ECC       FMsk(fNFCONT_ECC)
-#define NFCONT_ECC_NINIT FInsrt(0x0, fNFCONT_ECC)	/* not initialize */
-#define NFCONT_ECC_INIT  FInsrt(0x1, fNFCONT_ECC)	/* initialize */
-
-#define fNFCONT_MAINECC  Fld(1,5)
-#define NFCONT_MAINECC       FMsk(fNFCONT_MAINECC)
-#define NFCONT_MAINECC_UNLOCK FInsrt(0x0, fNFCONT_MAINECC)
-#define NFCONT_MAINECC_LOCK   FInsrt(0x1, fNFCONT_MAINECC)
-
-#define fNFCONF_ADDRSTEP Fld(1,13)	/* Addressing Step */
-#define NFCONF_ADDRSTEP  FMsk(fNFCONF_ADDRSTEP)
-
-/* S3C2440 H/W Set */
-#define fNFCONF_PAGESIZE Fld(1,2)
-#define NFCONF_PAGESIZE  FMsk(fNFCONF_PAGESIZE)
-#define NFCONF_PAGESIZE_256  FInsrt(0x0, fNFCONF_PAGESIZE)	/* 256 bytes */
-#define NFCONF_PAGESIZE_512  FInsrt(0x1, fNFCONF_PAGESIZE)	/* 512 bytes */
-
-#define fNFCONT_FCTRL    Fld(1,0)	/* Flash controller enable/disable */
-#define NFCONT_FCTRL     FMsk(fNFCONT_FCTRL)
-#define NFCONT_FCTRL_DIS FInsrt(0x0, fNFCONT_FCTRL)	/* Disable */
-#define NFCONT_FCTRL_EN  FInsrt(0x1, fNFCONT_FCTRL)	/* Enable */
-
-#define NFSTAT_RnB      (1 << 2)
-
-/*
- * Power Management
- */
-#define SPI_CLK		(1 << 18)
-#define IIS_CLK		(1 << 17)
-#define IIC_CLK		(1 << 16
-#define ADC_CLK		(1 << 15)
-#define RTC_CLK		(1 << 14)
-#define GPIO_CLK	(1 << 13)
-#define UART2_CLK	(1 << 12)
-#define UART1_CLK	(1 << 11)
-#define UART0_CLK	(1 << 10)
-#define SDI_CLK		(1 << 9)
-#define PWM_CLK		(1 << 8)
-#define USBSLAVE_CLK	(1 << 7)
-#define USBHOST_CLK	(1 << 6)
-#define LCDC_CLK	(1 << 5)
-#define NANDCTL_CLK	(1 << 4)
-#define SLEEP_ON	(1 << 3)
-#define IDLE		(1 << 2)
-
-#define GSTATUS(Nb)	__REG(0x560000AC + (Nb*4))
-#define GSTATUS0	GSTATUS(0)
-#define GSTATUS1	GSTATUS(1)
-#define GSTATUS2	GSTATUS(2)
-#define GSTATUS3	GSTATUS(3)
-#define GSTATUS4	GSTATUS(4)
-#define PMST		GSTATUS2
-#define PMSR0		GSTATUS3
-#define PMSR1		GSTATUS4
-#define PMCTL0		CLKCON
-#define PMCTL1		MISCCR
-#define SCLKE		(1 << 19)
-#define SCLK1		(1 << 18)
-#define SCLK0		(1 << 17)
-#define USBSPD1		(1 << 13)
-#define USBSPD0		(1 << 12)
-#define PMST_HWR	(1 << 0)
-#define PMST_SMR	(1 << 1)
-#define PMST_WDR	(1 << 2)
-
-#define HIDDEN(Nb)	__REG(0x560000C0 + (Nb*4))
-#define FLTOUT		HIDDEN(0)
-#define DSC0		HIDDEN(1)
-#define DSC1		HIDDEN(2)
-#define MSLCON		HIDDEN(3)
-
-#define NOINT 	0xc0
diff -rupN ../../Archives/vboot_20100106/vboot/smdk2440.h vboot//smdk2440.h
--- vboot/smdk2440.h	2011-12-22 17:11:57.721280783 +0000
+++ vboot//smdk2440.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,385 +0,0 @@
-/* handy sizes */
-#define SZ_1K                           0x00000400
-#define SZ_4K                           0x00001000
-#define SZ_8K                           0x00002000
-#define SZ_16K                          0x00004000
-#define SZ_32K                          0x00008000
-#define SZ_64K                          0x00010000
-#define SZ_128K                         0x00020000
-#define SZ_256K                         0x00040000
-#define SZ_512K                         0x00080000
-
-#define SZ_1M                           0x00100000
-#define SZ_2M                           0x00200000
-#define SZ_4M                           0x00400000
-#define SZ_8M                           0x00800000
-#define SZ_16M                          0x01000000
-#define SZ_32M                          0x02000000
-#define SZ_64M                          0x04000000
-#define SZ_128M                         0x08000000
-#define SZ_256M                         0x10000000
-#define SZ_512M                         0x20000000
-
-#define SZ_1G                           0x40000000
-#define SZ_2G                           0x80000000
-
-/* Porocessor memory map */
-#define ROM_BASE0		0x00000000	/* base address of rom bank 0 */
-#define ROM_BASE1		0x08000000	/* base address of rom bank 1 */
-#define DRAM_BASE0		0x30000000	/* base address of dram bank 0 */
-#define DRAM_BASE1		0x38000000	/* base address of dram bank 1 */
-
-#define DRAM_BASE		DRAM_BASE0
-#define DRAM_SIZE		SZ_64M
-
-/* RAM */
-#define RAM_BASE		DRAM_BASE
-
-/*
- * Architecture magic and machine type
- */
-#define UART_BAUD_RATE		115200
-#define FIN			12000000
-
-/* CPU clcok */
-/* 50.00 MHz */
-#define MDIV_50			0x5c
-#define PDIV_50			0x4
-#define SDIV_50			0x2
-
-/* 200.00 MHz */
-#define MDIV_200		0x5c
-#define PDIV_200		0x4
-#define SDIV_200		0x0
-
-/* 203.20 MHz */
-#define MDIV_203		0xf6
-#define PDIV_203		0xd
-#define SDIV_203		0x0
-#define CLKDVIN_203		0x3
-#define PCLK_DIV_203		4
-#define CPU_CLOCK_203 	       (/**/((MDIV_203 +8)*FIN)/((PDIV_203+2)*(1<<SDIV_203))/**/)
-#define UART_PCLK_203 	      	50800000
-#define vREFRESH_203		0x008e04ed
-
-/* 400.00 MHz */
-#define MDIV_400_148		0x5c
-#define PDIV_400_148		0x1
-#define SDIV_400_148		0x0
-#define CLKDVIN_400_148		0x5	/* 1:4:8 */
-#define UART_PCLK_400_148    	50000000
-#define vREFRESH_400_148	0x008e04eb
-
-/* 400.00 MHz */
-#define MDIV_400		0x5c
-#define PDIV_400		0x1
-#define SDIV_400		0x0
-#define CLKDVIN_400		0x7	/* 1:3:6 */
-#define PCLK_DIV_400		0x6
-/*
-#define UART_PCLK_400 	    
-((((MDIV_400 +8) *FIN )/((PDIV_400+2)*(1<<SDIV_400)))/PCLK_DIV_400)
-*/
-#define UART_PCLK_400 	   	66666000
-#define vREFRESH_400		0x008e045D
-
-/* 410.00MHz */
-#define MDIV_410		0xc5
-#define PDIV_410		0x4
-#define SDIV_410		0x0
-#define CLKDVIN_410		0x5	/* 1:4:8 */
-#define UART_PCLK_410	  	51250000
-#define vREFRESH_410		0x00aC04E1
-
-/* 451.20MHz */
-#define MDIV_451		0xb4
-#define PDIV_451		0x3
-#define SDIV_451		0x0
-#define CLKDVIN_451		0x5	/* 1:4:8 */
-#define UART_PCLK_451	  	56375000
-#define vREFRESH_451		0x00aC0491
-
-/* 474   MHz */
-#define MDIV_474		0x96
-#define PDIV_474		0x2
-#define SDIV_474		0x0
-#define CLKDVIN_474		0x5	/* 1:4:8 */
-#define PCLK_DIV_474		0x8
-#define UART_PCLK_474	  	59000000
-#define vREFRESH_474		0x00aC0465
-
-/* 508   MHz */
-#define MDIV_508		0x77
-#define PDIV_508		0x1
-#define SDIV_508		0x0
-#define CLKDVIN_508		0x5	/* 1:4:8 */
-#define PCLK_DIV_508		0x8
-#define UART_PCLK_508	  	63000000
-#define vREFRESH_508		0x00aC0423
-
-/* 532.8 MHz */
-#define MDIV_533		0xd6
-#define PDIV_533		0x3
-#define SDIV_533		0x0
-#define CLKDVIN_533		0x5	/* 1:4:8 */
-#define PCLK_DIV_533		0x8
-#define UART_PCLK_533	  	67000000
-#define vREFRESH_533		0x00aC03F4
-
-// laputa clock modify test only 031001 for s3c2440
-/* 90MHz */
-#define MDIV_090_112        0x57
-#define PDIV_090_112        0x0a
-#define SDIV_090_112        0x00
-#define CLKDVIN_090_112     0x1	/* 1:1:2 */
-#define UART_PCLK_090_112    45000000
-#define vREFRESH_090_112    0x008e04eb
-
-/* 100MHz */
-#define MDIV_100_112        0x5c
-#define PDIV_100_112        0x0a
-#define SDIV_100_112        0x00
-#define CLKDVIN_100_112     0x1	/* 1:1:2 */
-#define UART_PCLK_100_112    50000000
-#define vREFRESH_100_112    0x008e04eb
-
-/* 103MHz */
-#define MDIV_103_112        0x5f
-#define PDIV_103_112        0x0a
-#define SDIV_103_112        0x00
-#define CLKDVIN_103_112     0x1	/* 1:1:2 */
-#define UART_PCLK_103_112    50000000
-#define vREFRESH_103_112    0x008e04eb
-
-/* 120-120-61MHz */
-#define MDIV_120_112        0x70
-#define PDIV_120_112        0x0a
-#define SDIV_120_112        0x00
-#define CLKDVIN_120_112     0x1	/* 1:1:2 */
-#define UART_PCLK_120_112    60000000
-#define vREFRESH_120_112    0x008e04eb
-
-/* 131-131-65.5MHz */
-#define MDIV_131_112        0x7b
-#define PDIV_131_112        0x0a
-#define SDIV_131_112        0x00
-#define CLKDVIN_131_112     0x1	/* 1:1:2 */
-#define UART_PCLK_131_112    65500000
-#define vREFRESH_131_112    0x008e04eb
-
-/* 133-133-66.5MHz */
-#define MDIV_133_112        0x7d
-#define PDIV_133_112        0x0a
-#define SDIV_133_112        0x00
-#define CLKDVIN_133_112     0x1	/* 1:1:2 */
-#define UART_PCLK_133_112    66500000
-#define vREFRESH_133_112    0x008e04eb
-
-/* 135-135-67.5MHz */
-#define MDIV_135_112        0x7f
-#define PDIV_135_112        0x0a
-#define SDIV_135_112        0x00
-#define CLKDVIN_135_112     0x1	/* 1:1:2 */
-#define UART_PCLK_135_112    67500000
-#define vREFRESH_135_112    0x008e04eb
-
-/* 137-137-68.5MHz */
-#define MDIV_137_112        0x81
-#define PDIV_137_112        0x0a
-#define SDIV_137_112        0x00
-#define CLKDVIN_137_112     0x1	/* 1:1:2 */
-#define UART_PCLK_137_112    68500000
-#define vREFRESH_137_112    0x008e04eb
-
-/* 200MHz - 100MHz */
-#define MDIV_200_124        0x7e
-#define PDIV_200_124        0x06
-#define SDIV_200_124        0x00
-#define CLKDVIN_200_124     0x3	/* 1:2:4 */
-#define UART_PCLK_200_124    50000000
-#define vREFRESH_200_124    0x008e04eb
-
-/* 300MHz - 100MHz */
-#define MDIV_300_136        0x75
-#define PDIV_300_136        0x03
-#define SDIV_300_136        0x00
-#define CLKDVIN_300_136     0x7	/* 1:3:6 */
-#define UART_PCLK_300_136    50000000
-#define vREFRESH_300_136    0x008e04eb
-
-/* 266MHz - 133MHz */
-#define MDIV_266_124        0xaa
-#define PDIV_266_124        0x06
-#define SDIV_266_124        0x00
-#define CLKDVIN_266_124     0x3	/* 1:2:4 */
-#define UART_PCLK_266_124   66666666
-#define vREFRESH_266_124    0x008e04eb
-
-/* 400MHz - 133MHz */
-#define MDIV_400_136        0x5c
-#define PDIV_400_136        0x01
-#define SDIV_400_136        0x00
-#define CLKDVIN_400_136     0x7	/* 1:3:6 */
-#define UART_PCLK_400_136   66666666
-#define vREFRESH_400_136    0x008e04eb
-
-/* 412MHz - 137MHz */
-#define MDIV_412_136        0x5d
-#define PDIV_412_136        0x01
-#define SDIV_412_136        0x00
-#define CLKDVIN_412_136     0x7	/* 1:3:6 */
-#define UART_PCLK_412_136   68700000
-#define vREFRESH_412_136    0x008e04eb
-
-/* 412MHz - 103MHz */
-#define MDIV_412_148        0x5f
-#define PDIV_412_148        0x01
-#define SDIV_412_148        0x00
-#define CLKDVIN_412_148     0x5	/* 1:4:8 */
-#define UART_PCLK_412_148   51500000
-#define vREFRESH_412_148    0x008e04eb
-
-/* 440MHz - 148MHz */
-#define MDIV_440_148        0x66
-#define PDIV_440_148        0x01
-#define SDIV_440_148        0x00
-#define CLKDVIN_440_148     0x5	/* 1:4:8 */
-#define UART_PCLK_440_148   55000000
-#define vREFRESH_440_148    0x008e04eb
-
-/* 474MHz - 148MHz */
-#define MDIV_474_148        0x96
-#define PDIV_474_148        0x02
-#define SDIV_474_148        0x00
-#define CLKDVIN_474_148     0x5	/* 1:4:8 */
-#define UART_PCLK_474_148   59270000
-#define vREFRESH_474_148    0x008e04eb
-
-/* 500MHz - 124MHz */
-#define MDIV_500_148        0xc8
-#define PDIV_500_148        0x03
-#define SDIV_500_148        0x00
-#define CLKDVIN_500_148     0x5	/* 1:4:8 */
-#define UART_PCLK_500_148   62400000
-#define vREFRESH_500_148    0x008e04eb
-
-/* 534 MHz */
-#define MDIV_533_148        0x4e
-#define PDIV_533_148        0x0
-#define SDIV_533_148        0x0
-#define CLKDVIN_533_148     0x5	/* 1:4:8 */
-#define PCLK_DIV_533_148        0x8
-#define UART_PCLK_533_148       66800000
-#define vREFRESH_533_148        0x00aC03F4
-
-/* 528 MHz */
-#define MDIV_528_148        0xd4
-#define PDIV_528_148        0x3
-#define SDIV_528_148        0x0
-#define CLKDVIN_528_148     0x5	/* 1:4:8 */
-#define UART_PCLK_528_148       66000000
-#define vREFRESH_528_148        0x00aC03F4
-
-/* 542 MHz */
-#define MDIV_542_148        0xda
-#define PDIV_542_148        0x3
-#define SDIV_542_148        0x0
-#define CLKDVIN_542_148     0x5	/* 1:4:8 */
-#define UART_PCLK_542_148       67800000
-#define vREFRESH_542_148        0x00aC03F4
-
-// 031202 recommand freq for sound 44100Hz
-/* 203 MHz */
-#define MDIV_203_148        0x7f
-#define PDIV_203_148        0x02
-#define SDIV_203_148        0x01
-#define CLKDVIN_203_148     0x3	/* 1:2:4 */
-#define UART_PCLK_203_148       50800000
-#define vREFRESH_203_148        0x00aC03F4
-/* 304 MHz */
-#define MDIV_304_136        0x90
-#define PDIV_304_136        0x04
-#define SDIV_304_136        0x00
-#define CLKDVIN_304_136     0x7	/* 1:3:6 */
-#define UART_PCLK_304_136       50700000
-#define vREFRESH_304_136        0x00aC03F4
-/* 304d MHz */
-#define MDIV_304_136d        0x90
-#define PDIV_304_136d        0x01
-#define SDIV_304_136d        0x01
-#define CLKDVIN_304_136d     0x7	/* 1:3:6 */
-#define UART_PCLK_304_136d       50700000
-#define vREFRESH_304_136d        0x00aC03F4
-/* 406 MHz */
-#define MDIV_406_136        0xc3
-#define PDIV_406_136        0x04
-#define SDIV_406_136        0x0
-#define CLKDVIN_406_136     0x7	/* 1:3:6 */
-#define UART_PCLK_406_136       67700000
-#define vREFRESH_406_136        0x00aC03F4
-/* 406d MHz */
-#define MDIV_406_136d        0x7f
-#define PDIV_406_136d        0x02
-#define SDIV_406_136d        0x01
-#define CLKDVIN_406_136d     0x7	/* 1:3:6 */
-#define UART_PCLK_406_136d       67500000
-#define vREFRESH_406_136d        0x00aC03F4
-/* 540 MHz */
-#define MDIV_540_148        0xac
-#define PDIV_540_148        0x2
-#define SDIV_540_148        0x0
-#define CLKDVIN_540_148     0x5	/* 1:4:8 */
-#define UART_PCLK_540_148       67500000
-#define vREFRESH_540_148        0x00aC03F4
-//031202 end of recommand
-// laputa modify end
-
-/*** Change only This Value ******************/
-#define UART_PCLK           UART_PCLK_400_148
-#define vMPLLCON_NOW_USER   0x7f021
-#define vCLKDIVN_NOW        CLKDVIN_400_148
-#define vREFRESH            vREFRESH_400_148
-
-/* initial values for DRAM */
-#define vBWSCON			0x22111110
-#define vBANKCON0		0x00000700
-#define vBANKCON1		0x00000700
-#define vBANKCON2		0x00000700
-#define vBANKCON3		0x00000700
-#define vBANKCON4		0x00000700
-#define vBANKCON5		0x00000700
-#define vBANKCON6		0x00018009
-#define vBANKCON7		0x00018009
-
-#define vBANKSIZE		0xB2
-#define vMRSRB6			0x30
-#define vMRSRB7			0x30
-#define vLOCKTIME		0x00ffffff	/* It's a default value */
-#define vCLKCON			0x0000fff8	/* It's a default value */
-
-/* initial values for serial */
-#define vULCON			0x3	/* UART, no parity, one stop bit, 8 bits */
-#define vUCON			0x245
-#define vUFCON			0x0
-#define vUMCON			0x0
-
-/* inital values for GPIOs */
-#define vGPACON			0x007fffff
-#define vGPBCON			0x00044555
-#define vGPBUP			0x000007ff
-#define vGPCCON			0xaaaaaaaa
-#define vGPCUP			0x0000ffff
-#define vGPDCON			0xaaaaaaaa
-#define vGPDUP			0x0000ffff
-#define vGPECON			0xaaaaaaaa
-#define vGPEUP			0x0000ffff
-#define vGPFCON			0x000055aa
-#define vGPFUP			0x000000ff
-#define vGPGCON			0xff95ffba
-#define vGPGUP			0x0000ffff
-//#define vGPHCON                       0x00aaaa
-#define vGPHCON			0x0016faaa
-#define vGPHUP			0x000007ff
-#define vEXTINT0		0x22222222
-#define vEXTINT1		0x22222222
-#define vEXTINT2		0x22222222
diff -rupN ../../Archives/vboot_20100106/vboot/test.c vboot//test.c
--- vboot/test.c	1970-01-01 00:00:00.000000000 +0000
+++ vboot//test.c	2011-12-22 16:35:42.071480149 +0000
@@ -0,0 +1,27 @@
+
+#define BYTE_SECTOR_SHIFT  11
+#define SECTOR_BLOCK_SHIFT  6 
+
+#define SECTOR_SIZE (1 << BYTE_SECTOR_SHIFT)
+#define BLOCK_SIZE  (SECTOR_SIZE << SECTOR_BLOCK_SHIFT)
+#include "stdio.h"
+int g_os_length = 1986784;
+
+void test(int a, int b){
+	a = 3;
+	b = 1;
+	
+}
+
+int main(void){
+	int Length = g_os_length;
+	Length = (Length + BLOCK_SIZE - 1) >> (BYTE_SECTOR_SHIFT + SECTOR_BLOCK_SHIFT) << (BYTE_SECTOR_SHIFT + SECTOR_BLOCK_SHIFT); // align to 
+	int test1 = 1;
+	int test2 = 2;
+	printf("Pour la première boucle : La taille : %d, le nombre de boucle %d\n", Length, Length/BLOCK_SIZE);
+	printf("Pour la seconde boucle : La taille : %d, le nombre de boucle %d\n", SECTOR_SIZE, BLOCK_SIZE/SECTOR_SIZE);
+	test(test1,test2);
+	return 1;
+}
+
+
