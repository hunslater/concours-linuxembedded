diff -rupN linux-2.6.32.2//drivers/char/consolemap.c ../Projet-Theou/Compilation/linux//drivers/char/consolemap.c
--- linux-2.6.32.2//drivers/char/consolemap.c	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//drivers/char/consolemap.c	2011-12-18 18:03:38.916094327 +0000
@@ -22,6 +22,8 @@
 #include <linux/consolemap.h>
 #include <linux/vt_kern.h>
 
+#ifdef CONFIG_CONSOLE_TRANSLATIONS
+
 static unsigned short translations[][256] = {
   /* 8-bit Latin-1 mapped to Unicode -- trivial mapping */
   {
@@ -743,3 +745,79 @@ console_map_init(void)
 }
 
 EXPORT_SYMBOL(con_copy_unimap);
+
+#else
+
+u16 inverse_translate(struct vc_data *conp, int glyph, int use_unicode)
+{
+	return glyph;
+}
+
+unsigned short *set_translate(int m, struct vc_data *vc)
+{
+	return NULL;
+}
+
+int con_set_trans_old(unsigned char * arg)
+{
+	return 0;
+}
+
+int con_get_trans_old(unsigned char * arg)
+{
+	return -EINVAL;
+}
+
+int con_set_trans_new(ushort * arg)
+{
+	return 0;
+}
+
+int con_get_trans_new(ushort * arg)
+{
+	return -EINVAL;
+}
+
+int con_clear_unimap(struct vc_data *vc, struct unimapinit *ui)
+{
+	return 0;
+}
+
+int con_set_unimap(struct vc_data *vc, ushort ct, struct unipair *list)
+{
+	return 0;
+}
+
+int con_set_default_unimap(struct vc_data *vc)
+{
+	return 0;
+}
+
+int con_copy_unimap(struct vc_data *d, struct vc_data *s)
+{
+	return 0;
+}
+
+int con_get_unimap(struct vc_data *vc, ushort ct, ushort *uct,
+		   struct unipair *list)
+{
+	return -EINVAL;
+}
+
+void con_free_unimap(struct vc_data *vc) { }
+
+int conv_uni_to_pc(struct vc_data *conp, long ucs)
+{
+	return ucs > 0xff ? -1: ucs;
+}
+
+u32 conv_8bit_to_uni(unsigned char c)
+{
+	/* CAUTION: LINUX-TINY - Not sure this is correct */
+	return c;
+}
+
+
+void __init console_map_init(void) { }
+
+#endif
diff -rupN linux-2.6.32.2//drivers/char/vt.c ../Projet-Theou/Compilation/linux//drivers/char/vt.c
--- linux-2.6.32.2//drivers/char/vt.c	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//drivers/char/vt.c	2011-12-18 18:03:38.938094054 +0000
@@ -2230,7 +2230,11 @@ rescan_last_byte:
 			c = 0xfffd;
 		    tc = c;
 		} else {	/* no utf or alternate charset mode */
+#ifdef CONFIG_CONSOLE_TRANSLATIONS
 		    tc = vc_translate(vc, c);
+#else
+		    tc = c;
+#endif
 		}
 
 		param.c = tc;
diff -rupN linux-2.6.32.2//drivers/net/dm9000.c ../Projet-Theou/Compilation/linux//drivers/net/dm9000.c
--- linux-2.6.32.2//drivers/net/dm9000.c	2009-12-29 11:12:02.000000000 +0000
+++ linux//drivers/net/dm9000.c	2011-12-19 13:43:55.583668218 +0000

@@ -321,7 +321,7 @@
 static int dm9000_wait_eeprom(board_info_t *db)
 {
 	unsigned int status;
-	int timeout = 8;	/* wait max 8msec */
+	int timeout = 4;	/* wait max 8msec */
 
 	/* The DM9000 data sheets say we should be able to
 	 * poll the ERRE bit in EPCR to wait for the EEPROM
@@ -1094,6 +1094,7 @@
 
 	mii_check_media(&db->mii, netif_msg_link(db), 1);
 	netif_start_queue(dev);
+	
 	dm9000_schedule_poll(db);
 
 	return 0;
@@ -1575,7 +1576,7 @@
 	platform_driver_unregister(&dm9000_driver);
 }
 
-module_init(dm9000_init);
+earlydevice_initcall(dm9000_init);
 module_exit(dm9000_cleanup);
 
 MODULE_AUTHOR("Sascha Hauer, Ben Dooks");
diff -rupN linux-2.6.32.2//include/asm-generic/vmlinux.lds.h ../Projet-Theou/Compilation/linux//include/asm-generic/vmlinux.lds.h
--- linux-2.6.32.2//include/asm-generic/vmlinux.lds.h	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//include/asm-generic/vmlinux.lds.h	2011-12-18 20:58:09.158147779 +0000
@@ -590,6 +590,8 @@
   	*(.initcall3.init)						\
   	*(.initcall3s.init)						\
   	*(.initcall4.init)						\
+	*(.initcallearlydevice.init)					\
+	*(.initcallearlyconfig.init)					\
   	*(.initcall4s.init)						\
   	*(.initcall5.init)						\
   	*(.initcall5s.init)						\
diff -rupN linux-2.6.32.2//include/linux/ethtool.h ../Projet-Theou/Compilation/linux//include/linux/ethtool.h
--- linux-2.6.32.2//include/linux/ethtool.h	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//include/linux/ethtool.h	2011-12-18 18:03:39.005093215 +0000
@@ -378,6 +378,7 @@ struct ethtool_flash {
 
 struct net_device;
 
+#ifdef CONFIG_ETHTOOL
 /* Some generic methods drivers may use in their ethtool_ops */
 u32 ethtool_op_get_link(struct net_device *dev);
 u32 ethtool_op_get_rx_csum(struct net_device *dev);
@@ -393,6 +394,25 @@ u32 ethtool_op_get_ufo(struct net_device
 int ethtool_op_set_ufo(struct net_device *dev, u32 data);
 u32 ethtool_op_get_flags(struct net_device *dev);
 int ethtool_op_set_flags(struct net_device *dev, u32 data);
+#else
+static inline u32 ethtool_noop1(struct net_device *dev) { return 0; }
+static inline int ethtool_noop2(struct net_device *dev, u32 data) { return 0; }
+static inline int ethtool_noop3(struct net_device *dev,
+				struct ethtool_perm_addr *addr, u32 data) { return 0; }
+#define ethtool_op_get_link ethtool_noop1
+#define ethtool_op_get_tx_csum ethtool_noop1
+#define ethtool_op_set_tx_csum ethtool_noop2
+#define ethtool_op_set_tx_hw_csum ethtool_noop2
+#define ethtool_op_get_sg ethtool_noop1
+#define ethtool_op_set_sg ethtool_noop2
+#define ethtool_op_get_tso ethtool_noop1
+#define ethtool_op_set_tso ethtool_noop2
+#define ethtool_op_get_perm_addr ethtool_noop3
+#define ethtool_op_get_ufo ethtool_noop1
+#define ethtool_op_set_ufo ethtool_noop2
+#define ethtool_op_get_flags ethtool_noop1
+#define ethtool_op_set_flags ethtool_noop2
+#endif
 
 /**
  * &ethtool_ops - Alter and report network device settings
diff -rupN linux-2.6.32.2//include/linux/igmp.h ../Projet-Theou/Compilation/linux//include/linux/igmp.h
--- linux-2.6.32.2//include/linux/igmp.h	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//include/linux/igmp.h	2011-12-18 18:03:39.019093041 +0000
@@ -216,6 +216,7 @@ struct ip_mc_list
 #define IGMPV3_QQIC(value) IGMPV3_EXP(0x80, 4, 3, value)
 #define IGMPV3_MRC(value) IGMPV3_EXP(0x80, 4, 3, value)
 
+#ifdef CONFIG_IGMP
 extern int ip_check_mc(struct in_device *dev, __be32 mc_addr, __be32 src_addr, u16 proto);
 extern int igmp_rcv(struct sk_buff *);
 extern int ip_mc_join_group(struct sock *sk, struct ip_mreqn *imr);
@@ -238,6 +239,28 @@ extern void ip_mc_remap(struct in_device
 extern void ip_mc_dec_group(struct in_device *in_dev, __be32 addr);
 extern void ip_mc_inc_group(struct in_device *in_dev, __be32 addr);
 extern void ip_mc_rejoin_group(struct ip_mc_list *im);
+#else /* !CONFIG_IGMP */
+#define ip_check_mc(a, b, c, d) (0)
+#define igmp_rcv(a) (0)
+#define ip_mc_join_group(a, b) (0)
+#define ip_mc_leave_group(a, b) (0)
+#define ip_mc_drop_socket(a)
+#define ip_mc_source(a, b, c, d, e) (0)
+#define ip_mc_msfilter(a, b, c) (0)
+#define ip_mc_msfget(a, b, c, d) (0)
+#define ip_mc_gsfget(a, b, c, d) (0)
+#define ip_mc_sf_allow(a, b, c, d) (0)
+#define ip_mc_init_dev(a)
+#define ip_mc_destroy_dev(a)
+#define ip_mc_up(a)
+#define ip_mc_down(a)
+#define ip_mc_unmap(a)
+#define ip_mc_remap(a)
+#define ip_mc_dec_group(a, b)
+#define ip_mc_inc_group(a, b)
+#define ip_mc_rejoin_group(a)
+
+#endif
 
 #endif
 #endif
diff -rupN linux-2.6.32.2//include/linux/init.h ../Projet-Theou/Compilation/linux//include/linux/init.h
--- linux-2.6.32.2//include/linux/init.h	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//include/linux/init.h	2011-12-18 20:18:56.637558335 +0000
@@ -195,6 +195,8 @@ extern void (*late_time_init)(void);
 #define fs_initcall(fn)			__define_initcall("5",fn,5)
 #define fs_initcall_sync(fn)		__define_initcall("5s",fn,5s)
 #define rootfs_initcall(fn)		__define_initcall("rootfs",fn,rootfs)
+#define earlydevice_initcall(fn)	__define_initcall("earlydevice",fn,6)
+#define earlyconfig_initcall(fn)	__define_initcall("earlyconfig",fn,6)
 #define device_initcall(fn)		__define_initcall("6",fn,6)
 #define device_initcall_sync(fn)	__define_initcall("6s",fn,6s)
 #define late_initcall(fn)		__define_initcall("7",fn,7)
@@ -213,6 +215,8 @@ extern void (*late_time_init)(void);
 	static initcall_t __initcall_##fn \
 	__used __section(.security_initcall.init) = fn
 
+extern struct list_head autoip_fn_list;
+
 struct obs_kernel_param {
 	const char *str;
 	int (*setup_func)(char *);
diff -rupN linux-2.6.32.2//include/linux/mroute.h ../Projet-Theou/Compilation/linux//include/linux/mroute.h
--- linux-2.6.32.2//include/linux/mroute.h	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//include/linux/mroute.h	2011-12-18 18:03:39.032092877 +0000
@@ -148,8 +148,12 @@ static inline int ip_mroute_opt(int opt)
 extern int ip_mroute_setsockopt(struct sock *, int, char __user *, unsigned int);
 extern int ip_mroute_getsockopt(struct sock *, int, char __user *, int __user *);
 extern int ipmr_ioctl(struct sock *sk, int cmd, void __user *arg);
+#ifdef CONFIG_IGMP
 extern int ip_mr_init(void);
 #else
+static inline void ip_mr_init(void) {};
+#endif
+#else
 static inline
 int ip_mroute_setsockopt(struct sock *sock,
 			 int optname, char __user *optval, unsigned int optlen)
diff -rupN linux-2.6.32.2//include/linux/netdevice.h ../Projet-Theou/Compilation/linux//include/linux/netdevice.h
--- linux-2.6.32.2//include/linux/netdevice.h	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//include/linux/netdevice.h	2011-12-18 18:03:39.049092667 +0000
@@ -1862,8 +1862,18 @@ extern int		dev_unicast_delete(struct ne
 extern int		dev_unicast_add(struct net_device *dev, void *addr);
 extern int		dev_unicast_sync(struct net_device *to, struct net_device *from);
 extern void		dev_unicast_unsync(struct net_device *to, struct net_device *from);
+#ifdef CONFIG_NET_DEV_MULTICAST
 extern int 		dev_mc_delete(struct net_device *dev, void *addr, int alen, int all);
 extern int		dev_mc_add(struct net_device *dev, void *addr, int alen, int newonly);
+extern void		dev_mcast_init(void);
+#else
+#define	dev_mc_upload(a)
+static inline int dev_mc_delete(struct net_device *dev,
+				void *addr, int alen, int all) { return 0; }
+static inline int dev_mc_add(struct net_device *dev,
+			     void *addr, int alen, int newonly) { return 0; }
+#define dev_mcast_init()
+#endif
 extern int		dev_mc_sync(struct net_device *to, struct net_device *from);
 extern void		dev_mc_unsync(struct net_device *to, struct net_device *from);
 extern int 		__dev_addr_delete(struct dev_addr_list **list, int *count, void *addr, int alen, int all);
@@ -1878,7 +1888,7 @@ extern void		netdev_bonding_change(struc
 extern void		netdev_features_change(struct net_device *dev);
 /* Load a device via the kmod */
 extern void		dev_load(struct net *net, const char *name);
-extern void		dev_mcast_init(void);
+//extern void		dev_mcast_init(void);
 extern const struct net_device_stats *dev_get_stats(struct net_device *dev);
 
 extern int		netdev_max_backlog;
diff -rupN linux-2.6.32.2//include/net/icmp.h ../Projet-Theou/Compilation/linux//include/net/icmp.h
--- linux-2.6.32.2//include/net/icmp.h	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//include/net/icmp.h	2011-12-18 18:03:39.143091493 +0000
@@ -27,8 +27,11 @@ struct icmp_err {
   int		errno;
   unsigned	fatal:1;
 };
-
+#ifdef CONFIG_ICMP_PROTOCOL
 extern struct icmp_err icmp_err_convert[];
+#else
+#define icmp_err_convert
+#endif
 #define ICMP_INC_STATS(net, field)	SNMP_INC_STATS((net)->mib.icmp_statistics, field)
 #define ICMP_INC_STATS_BH(net, field)	SNMP_INC_STATS_BH((net)->mib.icmp_statistics, field)
 #define ICMPMSGOUT_INC_STATS(net, field)	SNMP_INC_STATS((net)->mib.icmpmsg_statistics, field+256)
@@ -38,13 +41,19 @@ struct dst_entry;
 struct net_proto_family;
 struct sk_buff;
 struct net;
-
+#ifdef CONFIG_ICMP_PROTOCOL
 extern void	icmp_send(struct sk_buff *skb_in,  int type, int code, __be32 info);
 extern int	icmp_rcv(struct sk_buff *skb);
 extern int	icmp_ioctl(struct sock *sk, int cmd, unsigned long arg);
 extern int	icmp_init(void);
 extern void	icmp_out_count(struct net *net, unsigned char type);
-
+#else
+#define icmp_send(a,b,c,d) 
+#define icmp_rcv(a) (0)
+#define icmp_ioctl(a,b,c) (0)
+#define icmp_init() (0)
+#define icmp_out_count(a,b)
+#endif
 /* Move into dst.h ? */
 extern int 	xrlim_allow(struct dst_entry *dst, int timeout);
 
diff -rupN linux-2.6.32.2//include/net/inetpeer.h ../Projet-Theou/Compilation/linux//include/net/inetpeer.h
--- linux-2.6.32.2//include/net/inetpeer.h	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//include/net/inetpeer.h	2011-12-18 18:03:39.148091429 +0000
@@ -28,7 +28,7 @@ struct inet_peer
 	__u32			tcp_ts;
 	unsigned long		tcp_ts_stamp;
 };
-
+#ifdef CONFIG_INETPEER
 void			inet_initpeers(void) __init;
 
 /* can be called with or without local BH being disabled */
@@ -49,5 +49,12 @@ static inline __u16	inet_getid(struct in
 	spin_unlock_bh(&inet_peer_idlock);
 	return id;
 }
+#else
+
+#define inet_getpeer(a, b) (0)
+#define inet_putpeer(b)
+static void inline inet_initpeers(void) { }
+#define inet_getid(a, b) (0)
 
+#endif
 #endif /* _NET_INETPEER_H */
diff -rupN linux-2.6.32.2//include/net/tcp.h ../Projet-Theou/Compilation/linux//include/net/tcp.h
--- linux-2.6.32.2//include/net/tcp.h	2010-01-05 07:05:08.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//include/net/tcp.h	2011-12-18 18:03:39.152091381 +0000
@@ -46,8 +46,11 @@
 #include <linux/seq_file.h>
 
 extern struct inet_hashinfo tcp_hashinfo;
-
+#ifdef CONFIG_TCP_PROTOCOL
 extern struct percpu_counter tcp_orphan_count;
+#else
+#define tcp_orphan_count (0)
+#endif
 extern void tcp_time_wait(struct sock *sk, int state, int timeo);
 
 #define MAX_TCP_HEADER	(128 + MAX_HEADER)
@@ -192,9 +195,11 @@ extern void tcp_time_wait(struct sock *s
 #define TCP_NAGLE_OFF		1	/* Nagle's algo is disabled */
 #define TCP_NAGLE_CORK		2	/* Socket is corked	    */
 #define TCP_NAGLE_PUSH		4	/* Cork is overridden for already queued data */
-
+#ifdef CONFIG_TCP_PROTOCOL
 extern struct inet_timewait_death_row tcp_death_row;
-
+#else
+#define tcp_death_row (0)
+#endif
 /* sysctl variables for tcp */
 extern int sysctl_tcp_timestamps;
 extern int sysctl_tcp_window_scaling;
@@ -204,7 +209,11 @@ extern int sysctl_tcp_keepalive_time;
 extern int sysctl_tcp_keepalive_probes;
 extern int sysctl_tcp_keepalive_intvl;
 extern int sysctl_tcp_syn_retries;
+#ifdef CONFIG_TCP_PROTOCOL
 extern int sysctl_tcp_synack_retries;
+#else
+#define sysctl_tcp_synack_retries 0
+#endif
 extern int sysctl_tcp_retries1;
 extern int sysctl_tcp_retries2;
 extern int sysctl_tcp_orphan_retries;
@@ -237,9 +246,13 @@ extern int sysctl_tcp_base_mss;
 extern int sysctl_tcp_workaround_signed_windows;
 extern int sysctl_tcp_slow_start_after_idle;
 extern int sysctl_tcp_max_ssthresh;
-
+#ifdef CONFIG_TCP_PROTOCOL
 extern atomic_t tcp_memory_allocated;
 extern struct percpu_counter tcp_sockets_allocated;
+#else
+#define tcp_memory_allocated (0)
+#define tcp_sockets_allocated (0)
+#endif
 extern int tcp_memory_pressure;
 
 /*
@@ -258,14 +271,16 @@ static inline int between(__u32 seq1, __
 {
 	return seq3 - seq2 >= seq1 - seq2;
 }
-
+#ifdef CONFIG_TCP_PROTOCOL
 static inline int tcp_too_many_orphans(struct sock *sk, int num)
 {
 	return (num > sysctl_tcp_max_orphans) ||
 		(sk->sk_wmem_queued > SOCK_MIN_SNDBUF &&
 		 atomic_read(&tcp_memory_allocated) > sysctl_tcp_mem[2]);
 }
-
+#else
+static inline int tcp_too_many_orphans(struct sock *sk, int num) {return 0;}
+#endif
 /* syncookies: remember time of last synqueue overflow */
 static inline void tcp_synq_overflow(struct sock *sk)
 {
@@ -278,9 +293,11 @@ static inline int tcp_synq_no_recent_ove
 	unsigned long last_overflow = tcp_sk(sk)->rx_opt.ts_recent_stamp;
 	return time_after(jiffies, last_overflow + TCP_TIMEOUT_INIT);
 }
-
+#ifdef CONFIG_TCP_PROTOCOL
 extern struct proto tcp_prot;
-
+#else
+#define tcp_prot (0)
+#endif
 #define TCP_INC_STATS(net, field)	SNMP_INC_STATS((net)->mib.tcp_statistics, field)
 #define TCP_INC_STATS_BH(net, field)	SNMP_INC_STATS_BH((net)->mib.tcp_statistics, field)
 #define TCP_DEC_STATS(net, field)	SNMP_DEC_STATS((net)->mib.tcp_statistics, field)
@@ -295,10 +312,17 @@ extern int			tcp_v4_rcv(struct sk_buff *
 extern int			tcp_v4_remember_stamp(struct sock *sk);
 
 extern int		    	tcp_v4_tw_remember_stamp(struct inet_timewait_sock *tw);
-
+#ifdef CONFIG_TCP_PROTOCOL
 extern int			tcp_sendmsg(struct kiocb *iocb, struct socket *sock,
 					    struct msghdr *msg, size_t size);
 extern ssize_t			tcp_sendpage(struct socket *sock, struct page *page, int offset, size_t size, int flags);
+#else
+#define tcp_sendmsg(a,b,c,d) (0)
+#define tcp_sendpage(a,b,c,d,e) (0)
+//int			tcp_sendmsg(struct kiocb *iocb, struct socket *sock,
+					   // struct msghdr *msg, size_t size) {return 0;}
+//ssize_t			tcp_sendpage(struct socket *sock, struct page *page, int offset, size_t size, int flags) {return 0;}
+#endif
 
 extern int			tcp_ioctl(struct sock *sk, 
 					  int cmd, 
@@ -322,10 +346,13 @@ extern int			tcp_twsk_unique(struct sock
 						struct sock *sktw, void *twp);
 
 extern void			tcp_twsk_destructor(struct sock *sk);
-
+#ifdef CONFIG_TCP_PROTOCOL
 extern ssize_t			tcp_splice_read(struct socket *sk, loff_t *ppos,
 					        struct pipe_inode_info *pipe, size_t len, unsigned int flags);
-
+#else
+//ssize_t			tcp_sendpage(struct socket *sock, struct page *page, int offset, size_t size, int flags) {return 0;}
+#define tcp_sendpage(a,b,c,d,e) (0)
+#endif
 static inline void tcp_dec_quickack_mode(struct sock *sk,
 					 const unsigned int pkts)
 {
@@ -386,8 +413,12 @@ extern void			tcp_update_metrics(struct
 
 extern void			tcp_close(struct sock *sk, 
 					  long timeout);
+#ifdef CONFIG_TCP_PROTOCOL
 extern unsigned int		tcp_poll(struct file * file, struct socket *sock, struct poll_table_struct *wait);
-
+#else
+//unsigned int tcp_poll (struct file * file, struct socket *sock, struct poll_table_struct *wait) {return 0;}
+#define tcp_poll (a,b,c) (0)
+#endif
 extern int			tcp_getsockopt(struct sock *sk, int level, 
 					       int optname,
 					       char __user *optval, 
@@ -401,7 +432,11 @@ extern int			compat_tcp_getsockopt(struc
 extern int			compat_tcp_setsockopt(struct sock *sk,
 					int level, int optname,
 					char __user *optval, unsigned int optlen);
+#ifdef CONFIG_TCP_PROTOCOL
 extern void			tcp_set_keepalive(struct sock *sk, int val);
+#else
+#define tcp_set_keepalive(a,b)
+#endif
 extern int			tcp_recvmsg(struct kiocb *iocb, struct sock *sk,
 					    struct msghdr *msg,
 					    size_t len, int nonblock, 
@@ -704,6 +739,7 @@ struct tcp_congestion_ops {
 	struct module 	*owner;
 };
 
+#ifdef CONFIG_TCP_PROTOCOL
 extern int tcp_register_congestion_control(struct tcp_congestion_ops *type);
 extern void tcp_unregister_congestion_control(struct tcp_congestion_ops *type);
 
@@ -723,6 +759,29 @@ extern u32 tcp_reno_ssthresh(struct sock
 extern void tcp_reno_cong_avoid(struct sock *sk, u32 ack, u32 in_flight);
 extern u32 tcp_reno_min_cwnd(const struct sock *sk);
 extern struct tcp_congestion_ops tcp_reno;
+#else 
+
+#define tcp_register_congestion_control(a) (0)
+#define tcp_unregister_congestion_control(a) 
+
+#define tcp_init_congestion_control(a) (a) 
+#define tcp_cleanup_congestion_control(a) 
+#define tcp_set_default_congestion_control(a) (0)
+#define tcp_get_default_congestion_control(a) (0)
+#define tcp_get_available_congestion_control(a,b) 
+#define tcp_get_allowed_congestion_control(a,b) 
+#define tcp_set_allowed_congestion_control(a) (0)
+#define tcp_set_congestion_control(a,b) (0)
+#define tcp_slow_start(a) 
+#define tcp_cong_avoid_ai(a,b)
+
+#define tcp_init_congestion_ops (0)
+#define tcp_reno_ssthresh(a) (0)
+#define tcp_reno_cong_avoid(a,b,c) (0)
+#define tcp_reno_min_cwnd(a) (0)
+#define tcp_reno (0)
+
+#endif
 
 static inline void tcp_set_ca_state(struct sock *sk, const u8 ca_state)
 {
@@ -1450,8 +1509,13 @@ extern int tcp_gro_complete(struct sk_bu
 extern int tcp4_gro_complete(struct sk_buff *skb);
 
 #ifdef CONFIG_PROC_FS
+#ifdef CONFIG_TCP_PROTOCOL
 extern int  tcp4_proc_init(void);
 extern void tcp4_proc_exit(void);
+#else
+#define tcp4_proc_init (0)
+#define tcp4_proc_exit (0)
+#endif
 #endif
 
 /* TCP af-specific functions */
diff -rupN linux-2.6.32.2//include/net/udplite.h ../Projet-Theou/Compilation/linux//include/net/udplite.h
--- linux-2.6.32.2//include/net/udplite.h	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//include/net/udplite.h	2011-12-18 18:03:39.165091216 +0000
@@ -9,8 +9,11 @@
 /* UDP-Lite socket options */
 #define UDPLITE_SEND_CSCOV   10 /* sender partial coverage (as sent)      */
 #define UDPLITE_RECV_CSCOV   11 /* receiver partial coverage (threshold ) */
-
+#ifdef CONFIG_UDPLITE_PROTOCOLE
 extern struct proto 		udplite_prot;
+#else
+#define udplite_prot
+#endif
 extern struct udp_table		udplite_table;
 
 /*
diff -rupN linux-2.6.32.2//init/Kconfig ../Projet-Theou/Compilation/linux//init/Kconfig
--- linux-2.6.32.2//init/Kconfig	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//init/Kconfig	2011-12-18 18:03:39.453087615 +0000
@@ -850,6 +850,82 @@ config BASE_FULL
 	  kernel data structures. This saves memory on small machines,
 	  but may reduce performance.
 
+config NET_DEV_MULTICAST
+	default y
+	depends on NET
+	bool "Enable device multicast support" if EMBEDDED
+	help
+	  This enables the core device multicast list management code.
+
+config ETHTOOL
+	depends on NET
+	default y
+	bool "Enable ethtool support" if EMBEDDED
+	help
+	  Disabling this option removes support for configuring
+	  ethernet device features via ethtool. Saves about 6k.
+
+config IGMP
+	depends on NET
+	default y
+	bool "Enable IGMP support" if EMBEDDED && !IP_MULTICAST
+	help
+	  This includes support for the Internet group management
+	  protocol, used for multicast.
+
+config INETPEER
+	default y
+	bool "Enable INET peer information storage" if EMBEDDED
+	help
+	  This allows storing various information about network peers.
+	  Disabling saves about 2k.
+
+config NR_LDISCS
+	int "Number of tty line disciplines" if EMBEDDED
+	range 0 16
+	default 16
+	help
+	  Select the maximum number of tty line disciplines. Embedded systems
+          can probably get by with only a few of these.
+
+config CONSOLE_TRANSLATIONS
+	default y
+	bool "Enable character translations in console" if EMBEDDED
+	help
+	  This enables support for font mapping and Unicode translation
+          on virtual consoles.
+
+config TCP_PROTOCOL
+	default y
+	bool "Enable TCP protocol on stack" if EMBEDDED
+	help
+	  This enable support for TCP protocol on stack (Be crasy to say no :) )
+
+config RAW_PROTOCOL
+	default y
+	bool "Enable RAW protocol on stack" if EMBEDDED
+	help
+	  This enable support for RAW protocol on stack (DO NOT SAY NO)
+
+config ICMP_PROTOCOL
+	default y
+	bool "Enable ICMP protocol on stack" if EMBEDDED
+	help
+	  This enable support for ICMP protocol on stack 
+
+config UDPLITE_PROTOCOL
+	default y
+	bool "Enable UDP lite protocol on stack" if EMBEDDED
+	help
+	  This enable support for UDP lite protocol on stack 
+
+config MAX_USER_RT_PRIO
+	int "Number of realtime priority levels" if EMBEDDED
+	range 5 100
+	default 100
+	help
+	  This option allows reducing the size of the O(1) scheduler arrays.
+
 config FUTEX
 	bool "Enable futex support" if EMBEDDED
 	default y
diff -rupN linux-2.6.32.2//init/main.c ../Projet-Theou/Compilation/linux//init/main.c
--- linux-2.6.32.2//init/main.c	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//init/main.c	2011-12-18 20:22:28.608908328 +0000
@@ -878,6 +878,8 @@ static int __init kernel_init(void * unu
 
 	do_basic_setup();
 
+
+	async_synchronize_full_domain(&autoip_fn_list);
 	/*
 	 * check if there is an early userspace init.  If yes, let it do all
 	 * the work
Binary files linux-2.6.32.2//initramfs.cpio and ../Projet-Theou/Compilation/linux//initramfs.cpio differ
diff -rupN linux-2.6.32.2//net/core/Makefile ../Projet-Theou/Compilation/linux//net/core/Makefile
--- linux-2.6.32.2//net/core/Makefile	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//net/core/Makefile	2011-12-18 18:03:39.253090114 +0000
@@ -8,7 +8,7 @@ obj-y := sock.o request_sock.o skbuff.o
 obj-$(CONFIG_SYSCTL) += sysctl_net_core.o
 obj-$(CONFIG_HAS_DMA) += skb_dma_map.o
 
-obj-y		     += dev.o ethtool.o dev_mcast.o dst.o netevent.o \
+obj-y		     += dev.o  dst.o netevent.o \
 			neighbour.o rtnetlink.o utils.o link_watch.o filter.o
 
 obj-$(CONFIG_XFRM) += flow.o
@@ -17,6 +17,8 @@ obj-$(CONFIG_NET_PKTGEN) += pktgen.o
 obj-$(CONFIG_NETPOLL) += netpoll.o
 obj-$(CONFIG_NET_DMA) += user_dma.o
 obj-$(CONFIG_FIB_RULES) += fib_rules.o
+obj-$(CONFIG_ETHTOOL) += ethtool.o
+obj-$(CONFIG_NET_DEV_MULTICAST) += dev_mcast.o
 obj-$(CONFIG_TRACEPOINTS) += net-traces.o
 obj-$(CONFIG_NET_DROP_MONITOR) += drop_monitor.o
 
diff -rupN linux-2.6.32.2//net/core/dev.c ../Projet-Theou/Compilation/linux//net/core/dev.c
--- linux-2.6.32.2//net/core/dev.c	2010-01-05 07:05:08.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//net/core/dev.c	2011-12-18 18:03:39.229090415 +0000
@@ -4504,6 +4504,7 @@ int dev_ioctl(struct net *net, unsigned
 		return ret;
 
 	case SIOCETHTOOL:
+#ifdef CONFIG_ETHTOOL
 		dev_load(net, ifr.ifr_name);
 		rtnl_lock();
 		ret = dev_ethtool(net, &ifr);
@@ -4516,6 +4517,9 @@ int dev_ioctl(struct net *net, unsigned
 				ret = -EFAULT;
 		}
 		return ret;
+#else
+		return -EINVAL;
+#endif
 
 	/*
 	 *	These ioctl calls:
diff -rupN linux-2.6.32.2//net/ipv4/Makefile ../Projet-Theou/Compilation/linux//net/ipv4/Makefile
--- linux-2.6.32.2//net/ipv4/Makefile	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//net/ipv4/Makefile	2011-12-18 18:03:39.290089656 +0000
@@ -2,21 +2,25 @@
 # Makefile for the Linux TCP/IP (INET) layer.
 #
 
-obj-y     := route.o inetpeer.o protocol.o \
+obj-y     := route.o protocol.o \
 	     ip_input.o ip_fragment.o ip_forward.o ip_options.o \
 	     ip_output.o ip_sockglue.o inet_hashtables.o \
 	     inet_timewait_sock.o inet_connection_sock.o \
-	     tcp.o tcp_input.o tcp_output.o tcp_timer.o tcp_ipv4.o \
-	     tcp_minisocks.o tcp_cong.o \
-	     datagram.o raw.o udp.o udplite.o \
-	     arp.o icmp.o devinet.o af_inet.o  igmp.o \
+	     datagram.o udp.o  \
+	     arp.o  devinet.o af_inet.o  \
 	     fib_frontend.o fib_semantics.o \
 	     inet_fragment.o
 
+obj-$(CONFIG_TCP_PROTOCOL) += tcp.o tcp_input.o tcp_output.o tcp_timer.o tcp_ipv4.o tcp_minisocks.o tcp_cong.o tcp_cubic.o
+obj-$(CONFIG_RAW_PROTOCOL) += raw.o
+obj-$(CONFIG_ICMP_PROTOCOL) += icmp.o
+obj-$(CONFIG_UDPLITE_PROTOCOL) += udplite.o
 obj-$(CONFIG_SYSCTL) += sysctl_net_ipv4.o
 obj-$(CONFIG_IP_FIB_HASH) += fib_hash.o
 obj-$(CONFIG_IP_FIB_TRIE) += fib_trie.o
 obj-$(CONFIG_PROC_FS) += proc.o
+obj-$(CONFIG_IGMP) += igmp.o
+obj-$(CONFIG_INETPEER) += inetpeer.o
 obj-$(CONFIG_IP_MULTIPLE_TABLES) += fib_rules.o
 obj-$(CONFIG_IP_MROUTE) += ipmr.o
 obj-$(CONFIG_NET_IPIP) += ipip.o
@@ -37,7 +41,7 @@ obj-$(CONFIG_INET_DIAG) += inet_diag.o
 obj-$(CONFIG_INET_TCP_DIAG) += tcp_diag.o
 obj-$(CONFIG_NET_TCPPROBE) += tcp_probe.o
 obj-$(CONFIG_TCP_CONG_BIC) += tcp_bic.o
-obj-$(CONFIG_TCP_CONG_CUBIC) += tcp_cubic.o
+#obj-$(CONFIG_TCP_CONG_CUBIC) += tcp_cubic.o
 obj-$(CONFIG_TCP_CONG_WESTWOOD) += tcp_westwood.o
 obj-$(CONFIG_TCP_CONG_HSTCP) += tcp_highspeed.o
 obj-$(CONFIG_TCP_CONG_HYBLA) += tcp_hybla.o
diff -rupN linux-2.6.32.2//net/ipv4/af_inet.c ../Projet-Theou/Compilation/linux//net/ipv4/af_inet.c
--- linux-2.6.32.2//net/ipv4/af_inet.c	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//net/ipv4/af_inet.c	2011-12-18 18:03:39.272089879 +0000
@@ -418,7 +418,7 @@ int inet_release(struct socket *sock)
 		long timeout;
 
 		/* Applications forget to leave groups before exiting */
-		ip_mc_drop_socket(sk);
+		//ip_mc_drop_socket(sk);
 
 		/* If linger is set, we don't return until the close
 		 * is complete.  Otherwise we return immediately. The
@@ -858,17 +858,23 @@ const struct proto_ops inet_stream_ops =
 	.socketpair	   = sock_no_socketpair,
 	.accept		   = inet_accept,
 	.getname	   = inet_getname,
+#ifdef CONFIG_TCP_PROTOCOL
 	.poll		   = tcp_poll,
+#endif
 	.ioctl		   = inet_ioctl,
 	.listen		   = inet_listen,
 	.shutdown	   = inet_shutdown,
 	.setsockopt	   = sock_common_setsockopt,
 	.getsockopt	   = sock_common_getsockopt,
+#ifdef CONFIG_TCP_PROTOCOL
 	.sendmsg	   = tcp_sendmsg,
+#endif
 	.recvmsg	   = sock_common_recvmsg,
 	.mmap		   = sock_no_mmap,
+#ifdef CONFIG_TCP_PROTOCOL
 	.sendpage	   = tcp_sendpage,
 	.splice_read	   = tcp_splice_read,
+#endif
 #ifdef CONFIG_COMPAT
 	.compat_setsockopt = compat_sock_common_setsockopt,
 	.compat_getsockopt = compat_sock_common_getsockopt,
@@ -942,6 +948,7 @@ static struct net_proto_family inet_fami
  */
 static struct inet_protosw inetsw_array[] =
 {
+#ifdef CONFIG_TCP_PROTOCOL
 	{
 		.type =       SOCK_STREAM,
 		.protocol =   IPPROTO_TCP,
@@ -952,7 +959,7 @@ static struct inet_protosw inetsw_array[
 		.flags =      INET_PROTOSW_PERMANENT |
 			      INET_PROTOSW_ICSK,
 	},
-
+#endif
 	{
 		.type =       SOCK_DGRAM,
 		.protocol =   IPPROTO_UDP,
@@ -1453,13 +1460,13 @@ static const struct net_protocol udp_pro
 	.no_policy =	1,
 	.netns_ok =	1,
 };
-
+#ifdef CONFIG_ICMP_PROTOCOL
 static const struct net_protocol icmp_protocol = {
 	.handler =	icmp_rcv,
 	.no_policy =	1,
 	.netns_ok =	1,
 };
-
+#endif
 static __net_init int ipv4_mib_init_net(struct net *net)
 {
 	if (snmp_mib_init((void **)net->mib.tcp_statistics,
@@ -1545,25 +1552,24 @@ static int __init inet_init(void)
 	struct inet_protosw *q;
 	struct list_head *r;
 	int rc = -EINVAL;
-
 	BUILD_BUG_ON(sizeof(struct inet_skb_parm) > sizeof(dummy_skb->cb));
-
+#ifdef CONFIG_TCP_PROTOCOL
 	rc = proto_register(&tcp_prot, 1);
 	if (rc)
 		goto out;
-
+#endif
 	rc = proto_register(&udp_prot, 1);
-	if (rc)
+	if (rc){
 		goto out_unregister_tcp_proto;
-
+	}
+#ifdef CONFIG_RAW_PROTOCOL
 	rc = proto_register(&raw_prot, 1);
 	if (rc)
 		goto out_unregister_udp_proto;
-
+#endif
 	/*
 	 *	Tell SOCKET that we are alive...
 	 */
-
 	(void)sock_register(&inet_family_ops);
 
 #ifdef CONFIG_SYSCTL
@@ -1573,13 +1579,16 @@ static int __init inet_init(void)
 	/*
 	 *	Add all the base protocols.
 	 */
-
+#ifdef CONFIG_ICMP_PROTOCOL
 	if (inet_add_protocol(&icmp_protocol, IPPROTO_ICMP) < 0)
 		printk(KERN_CRIT "inet_init: Cannot add ICMP protocol\n");
+#endif
 	if (inet_add_protocol(&udp_protocol, IPPROTO_UDP) < 0)
 		printk(KERN_CRIT "inet_init: Cannot add UDP protocol\n");
+#ifdef CONFIG_TCP_PROTOCOL
 	if (inet_add_protocol(&tcp_protocol, IPPROTO_TCP) < 0)
 		printk(KERN_CRIT "inet_init: Cannot add TCP protocol\n");
+#endif
 #ifdef CONFIG_IP_MULTICAST
 	if (inet_add_protocol(&igmp_protocol, IPPROTO_IGMP) < 0)
 		printk(KERN_CRIT "inet_init: Cannot add IGMP protocol\n");
@@ -1603,24 +1612,26 @@ static int __init inet_init(void)
 	 */
 
 	ip_init();
-
+#ifdef CONFIG_TCP_PROTOCOL
 	tcp_v4_init();
 
 	/* Setup TCP slab cache for open requests. */
 	tcp_init();
-
+#endif
 	/* Setup UDP memory threshold */
 	udp_init();
 
 	/* Add UDP-Lite (RFC 3828) */
+#ifdef CONFIG_UDPLITE
 	udplite4_register();
-
+#endif
 	/*
 	 *	Set the ICMP layer up
 	 */
-
+#ifdef CONFIG_ICMP_PROTOCOL
 	if (icmp_init() < 0)
 		panic("Failed to create the ICMP control socket.\n");
+#endif
 
 	/*
 	 *	Initialise the multicast router
@@ -1648,7 +1659,9 @@ out:
 out_unregister_udp_proto:
 	proto_unregister(&udp_prot);
 out_unregister_tcp_proto:
+#ifdef CONFIG_TCP_PROTOCOL
 	proto_unregister(&tcp_prot);
+#endif
 	goto out;
 }
 
@@ -1660,11 +1673,14 @@ fs_initcall(inet_init);
 static int __init ipv4_proc_init(void)
 {
 	int rc = 0;
-
+#ifdef CONFIG_RAW_PROTOCOL
 	if (raw_proc_init())
 		goto out_raw;
+#endif
+#ifdef CONFIG_TCP_PROTOCOL
 	if (tcp4_proc_init())
 		goto out_tcp;
+#endif
 	if (udp4_proc_init())
 		goto out_udp;
 	if (ip_misc_proc_init())
@@ -1674,9 +1690,13 @@ out:
 out_misc:
 	udp4_proc_exit();
 out_udp:
+#ifdef CONFIG_TCP_PROTOCOL
 	tcp4_proc_exit();
+#endif
 out_tcp:
+#ifdef CONFIG_RAW_PROTOCOL
 	raw_proc_exit();
+#endif 
 out_raw:
 	rc = -ENOMEM;
 	goto out;
diff -rupN linux-2.6.32.2//net/ipv4/inet_connection_sock.c ../Projet-Theou/Compilation/linux//net/ipv4/inet_connection_sock.c
--- linux-2.6.32.2//net/ipv4/inet_connection_sock.c	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//net/ipv4/inet_connection_sock.c	2011-12-18 18:03:39.276089831 +0000
@@ -442,8 +442,9 @@ void inet_csk_reqsk_queue_hash_add(struc
 }
 
 /* Only thing we need from tcp.h */
+#ifdef CONFIG_TCP_PROTOCOL
 extern int sysctl_tcp_synack_retries;
-
+#endif
 EXPORT_SYMBOL_GPL(inet_csk_reqsk_queue_hash_add);
 
 /* Decide when to expire the request and when to resend SYN-ACK */
@@ -476,7 +477,11 @@ void inet_csk_reqsk_queue_prune(struct s
 	struct inet_connection_sock *icsk = inet_csk(parent);
 	struct request_sock_queue *queue = &icsk->icsk_accept_queue;
 	struct listen_sock *lopt = queue->listen_opt;
+#ifdef CONFIG_TCP_PROTOCOL
 	int max_retries = icsk->icsk_syn_retries ? : sysctl_tcp_synack_retries;
+#else
+	int max_retries = 0;
+#endif
 	int thresh = max_retries;
 	unsigned long now = jiffies;
 	struct request_sock **reqp, *req;
diff -rupN linux-2.6.32.2//net/ipv4/ip_sockglue.c ../Projet-Theou/Compilation/linux//net/ipv4/ip_sockglue.c
--- linux-2.6.32.2//net/ipv4/ip_sockglue.c	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//net/ipv4/ip_sockglue.c	2011-12-18 18:03:39.281089766 +0000
@@ -683,6 +683,7 @@ static int do_ip_setsockopt(struct sock
 			err = ip_mc_leave_group(sk, &mreq);
 		break;
 	}
+#ifdef CONFIG_IGMP
 	case IP_MSFILTER:
 	{
 		struct ip_msfilter *msf;
@@ -719,6 +720,7 @@ static int do_ip_setsockopt(struct sock
 		kfree(msf);
 		break;
 	}
+#endif
 	case IP_BLOCK_SOURCE:
 	case IP_UNBLOCK_SOURCE:
 	case IP_ADD_SOURCE_MEMBERSHIP:
@@ -836,6 +838,7 @@ static int do_ip_setsockopt(struct sock
 				   greqs.gsr_interface);
 		break;
 	}
+#ifdef CONFIG_IGMP
 	case MCAST_MSFILTER:
 	{
 		struct sockaddr_in *psin;
@@ -908,6 +911,7 @@ mc_msf_out:
 			goto e_inval;
 		inet->mc_all = val;
 		break;
+#endif
 	case IP_ROUTER_ALERT:
 		err = ip_ra_control(sk, val ? 1 : 0, NULL);
 		break;
diff -rupN linux-2.6.32.2//net/ipv4/ipconfig.c ../Projet-Theou/Compilation/linux//net/ipv4/ipconfig.c
--- linux-2.6.32.2//net/ipv4/ipconfig.c	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//net/ipv4/ipconfig.c	2011-12-18 20:39:26.098187961 +0000
@@ -62,7 +62,7 @@
 #include <asm/uaccess.h>
 #include <net/checksum.h>
 #include <asm/processor.h>
-
+#include <linux/async.h>
 /* Define this to allow debugging output */
 #undef IPCONFIG_DEBUG
 
@@ -1307,8 +1307,11 @@ __be32 __init root_nfs_parse_addr(char *
 /*
  *	IP Autoconfig dispatcher.
  */
+LIST_HEAD(autoip_fn_list);
+
+
 
-static int __init ip_auto_config(void)
+static void __init async_ip_auto_config(void)
 {
 	__be32 addr;
 #ifdef IPCONFIG_DYNAMIC
@@ -1327,14 +1330,14 @@ static int __init ip_auto_config(void)
  try_try_again:
 #endif
 	/* Give hardware a chance to settle */
-	msleep(CONF_PRE_OPEN);
+	//msleep(CONF_PRE_OPEN);
 
 	/* Setup all network devices */
 	if (ic_open_devs() < 0)
-		return -1;
+		return ;
 
 	/* Give drivers a chance to settle */
-	ssleep(CONF_POST_OPEN);
+	//ssleep(CONF_POST_OPEN);
 
 	/*
 	 * If the config information is insufficient (e.g., our IP address or
@@ -1383,12 +1386,12 @@ static int __init ip_auto_config(void)
 
 			/* Oh, well.  At least we tried. */
 			printk(KERN_ERR "IP-Config: Auto-configuration of network failed.\n");
-			return -1;
+			return ;
 		}
 #else /* !DYNAMIC */
 		printk(KERN_ERR "IP-Config: Incomplete network configuration information.\n");
 		ic_close_devs();
-		return -1;
+		return ;
 #endif /* IPCONFIG_DYNAMIC */
 	} else {
 		/* Device selected manually or only one device -> use it */
@@ -1403,7 +1406,7 @@ static int __init ip_auto_config(void)
 	 * Use defaults whereever applicable.
 	 */
 	if (ic_defaults() < 0)
-		return -1;
+		return ;
 
 	/*
 	 * Close all network devices except the device we've
@@ -1411,7 +1414,7 @@ static int __init ip_auto_config(void)
 	 */
 	ic_close_devs();
 	if (ic_setup_if() < 0 || ic_setup_routes() < 0)
-		return -1;
+		return ;
 
 	/*
 	 * Record which protocol was actually used.
@@ -1439,10 +1442,15 @@ static int __init ip_auto_config(void)
 	printk("\n");
 #endif /* !SILENT */
 
-	return 0;
+	return ;
+}
+
+static int __init ip_auto_config(void){
+	async_schedule_domain(async_ip_auto_config,NULL,&autoip_fn_list);
 }
 
-late_initcall(ip_auto_config);
+earlyconfig_initcall(ip_auto_config);
+//late_initcall(ip_auto_config);
 
 
 /*
diff -rupN linux-2.6.32.2//net/ipv4/proc.c ../Projet-Theou/Compilation/linux//net/ipv4/proc.c
--- linux-2.6.32.2//net/ipv4/proc.c	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//net/ipv4/proc.c	2011-12-18 18:03:39.292089630 +0000
@@ -54,22 +54,33 @@ static int sockstat_seq_show(struct seq_
 	int orphans, sockets;
 
 	local_bh_disable();
+#ifdef CONFIG_TCP_PROTOCOL
 	orphans = percpu_counter_sum_positive(&tcp_orphan_count);
 	sockets = percpu_counter_sum_positive(&tcp_sockets_allocated);
+#else
+	orphans = percpu_counter_sum_positive(NULL);
+	sockets = percpu_counter_sum_positive(NULL);
+#endif
 	local_bh_enable();
 
 	socket_seq_show(seq);
+#ifdef CONFIG_TCP_PROTOCOL
 	seq_printf(seq, "TCP: inuse %d orphan %d tw %d alloc %d mem %d\n",
 		   sock_prot_inuse_get(net, &tcp_prot), orphans,
 		   tcp_death_row.tw_count, sockets,
 		   atomic_read(&tcp_memory_allocated));
+#endif
 	seq_printf(seq, "UDP: inuse %d mem %d\n",
 		   sock_prot_inuse_get(net, &udp_prot),
 		   atomic_read(&udp_memory_allocated));
+#ifdef CONFIG_UDPLITE_PROTOCOL
 	seq_printf(seq, "UDPLITE: inuse %d\n",
 		   sock_prot_inuse_get(net, &udplite_prot));
+#endif
+#ifdef CONFIG_RAW_PROTOCOL
 	seq_printf(seq, "RAW: inuse %d\n",
 		   sock_prot_inuse_get(net, &raw_prot));
+#endif
 	seq_printf(seq,  "FRAG: inuse %d memory %d\n",
 			ip_frag_nqueues(net), ip_frag_mem(net));
 	return 0;
diff -rupN linux-2.6.32.2//net/ipv4/raw.c ../Projet-Theou/Compilation/linux//net/ipv4/raw.c
--- linux-2.6.32.2//net/ipv4/raw.c	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//net/ipv4/raw.c	2011-12-18 18:03:39.313089364 +0000
@@ -238,8 +238,10 @@ static void raw_err(struct sock *sk, str
 		err = EHOSTUNREACH;
 		if (code > NR_ICMP_UNREACH)
 			break;
+#ifdef CONFIG_ICMP_CONFIG
 		err = icmp_err_convert[code].errno;
 		harderr = icmp_err_convert[code].fatal;
+#endif
 		if (code == ICMP_FRAG_NEEDED) {
 			harderr = inet->pmtudisc != IP_PMTUDISC_DONT;
 			err = EMSGSIZE;
diff -rupN linux-2.6.32.2//net/ipv4/sysctl_net_ipv4.c ../Projet-Theou/Compilation/linux//net/ipv4/sysctl_net_ipv4.c
--- linux-2.6.32.2//net/ipv4/sysctl_net_ipv4.c	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//net/ipv4/sysctl_net_ipv4.c	2011-12-18 18:03:39.325089217 +0000
@@ -247,6 +247,7 @@ static struct ctl_table ipv4_table[] = {
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec
 	},
+#ifdef CONFIG_TCP_CONFIG
 	{
 		.ctl_name	= NET_IPV4_TCP_SYN_RETRIES,
 		.procname	= "tcp_syn_retries",
@@ -279,6 +280,7 @@ static struct ctl_table ipv4_table[] = {
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec
 	},
+#endif
 	{
 		.ctl_name	= NET_IPV4_DYNADDR,
 		.procname	= "ip_dynaddr",
@@ -287,6 +289,7 @@ static struct ctl_table ipv4_table[] = {
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec
 	},
+#ifdef CONFIG_TCP_CONFIG
 	{
 		.ctl_name	= NET_IPV4_TCP_KEEPALIVE_TIME,
 		.procname	= "tcp_keepalive_time",
@@ -390,6 +393,7 @@ static struct ctl_table ipv4_table[] = {
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec
 	},
+#endif
 	{
 		.ctl_name	= NET_IPV4_LOCAL_PORT_RANGE,
 		.procname	= "ip_local_port_range",
@@ -410,6 +414,8 @@ static struct ctl_table ipv4_table[] = {
 	},
 
 #endif
+#ifdef CONFIG_INETPEER
+#ifdef CONFIG_IGMP
 	{
 		.ctl_name	= NET_IPV4_IGMP_MAX_MSF,
 		.procname	= "igmp_max_msf",
@@ -418,6 +424,7 @@ static struct ctl_table ipv4_table[] = {
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec
 	},
+#endif
 	{
 		.ctl_name	= NET_IPV4_INET_PEER_THRESHOLD,
 		.procname	= "inet_peer_threshold",
@@ -462,6 +469,7 @@ static struct ctl_table ipv4_table[] = {
 		.proc_handler	= proc_dointvec_jiffies,
 		.strategy	= sysctl_jiffies
 	},
+#endif
 	{
 		.ctl_name	= NET_TCP_ORPHAN_RETRIES,
 		.procname	= "tcp_orphan_retries",
@@ -470,6 +478,7 @@ static struct ctl_table ipv4_table[] = {
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec
 	},
+#ifdef CONFIG_TCP_CONFIG
 	{
 		.ctl_name	= NET_TCP_FACK,
 		.procname	= "tcp_fack",
@@ -656,6 +665,7 @@ static struct ctl_table ipv4_table[] = {
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec
 	},
+#endif
 #ifdef CONFIG_NETLABEL
 	{
 		.ctl_name	= NET_CIPSOV4_CACHE_ENABLE,
@@ -690,6 +700,7 @@ static struct ctl_table ipv4_table[] = {
 		.proc_handler	= proc_dointvec,
 	},
 #endif /* CONFIG_NETLABEL */
+#ifdef CONFIG_TCP_CONFIG
 	{
 		.procname	= "tcp_available_congestion_control",
 		.maxlen		= TCP_CA_BUF_MAX,
@@ -712,6 +723,7 @@ static struct ctl_table ipv4_table[] = {
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec,
 	},
+#endif
 	{
 		.ctl_name	= CTL_UNNUMBERED,
 		.procname	= "udp_mem",
diff -rupN linux-2.6.32.2//net/ipv4/udp.c ../Projet-Theou/Compilation/linux//net/ipv4/udp.c
--- linux-2.6.32.2//net/ipv4/udp.c	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//net/ipv4/udp.c	2011-12-18 18:03:39.335089093 +0000
@@ -426,10 +426,12 @@ void __udp4_lib_err(struct sk_buff *skb,
 			goto out;
 		}
 		err = EHOSTUNREACH;
+#ifdef CONFIG_ICMP_PROTOCOL
 		if (code <= NR_ICMP_UNREACH) {
 			harderr = icmp_err_convert[code].fatal;
 			err = icmp_err_convert[code].errno;
 		}
+#endif
 		break;
 	}
 
diff -rupN linux-2.6.32.2//net/socket.c ../Projet-Theou/Compilation/linux//net/socket.c
--- linux-2.6.32.2//net/socket.c	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//net/socket.c	2011-12-18 18:03:39.402088253 +0000
@@ -2224,7 +2224,7 @@ int sock_register(const struct net_proto
 }
 
 /**
- *	sock_unregister - remove a protocol handler
+ *		sock_unregister - remove a protocol handler
  *	@family: protocol family to remove
  *
  *	This function is called by a protocol handler that wants to
diff -rupN linux-2.6.32.2//net/sunrpc/cache.c ../Projet-Theou/Compilation/linux//net/sunrpc/cache.c
--- linux-2.6.32.2//net/sunrpc/cache.c	2009-12-03 03:51:21.000000000 +0000
+++ ../Projet-Theou/Compilation/linux//net/sunrpc/cache.c	2011-12-18 18:03:39.429087916 +0000
@@ -488,6 +488,8 @@ EXPORT_SYMBOL_GPL(cache_purge);
  * it to be revisited when cache info is available
  */
 
+
+// Application du patch cache_defer_cache 
 #define	DFR_HASHSIZE	(PAGE_SIZE/sizeof(struct list_head))
 #define	DFR_HASH(item)	((((long)item)>>4 ^ (((long)item)>>13)) % DFR_HASHSIZE)
 
